# 344题: 字符串反转I

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        # method 1: use reverse()
        # s.reverse() # 原地反转, 无返回值
        
        # method 2: use two-pointer approach
        # left, right= 0, len(s)-1
        # while left < right:
        #     s[left], s[right] = s[right], s[left]
        #     left += 1
        #     right -= 1

        # method 3: use range function: 因为while每次循环需要进行条件判断，而range函数不需要，直接生成数字，因此时间复杂度更低。推荐使用range
        n = len(s)
        n = len(s)
        for i in range(n // 2): # 只要控制了长度一半以内的元素, 另外一半也就控制住了, 这里无需判断奇数/偶数
            s[i], s[n-i-1] = s[n-i-1], s[i]
```



Read [](file:///Users/yichen/Documents/Leetcode/leetcode-notes/344.reverse-string.py)

三种方法的时间复杂度都是 **O(n)**（n 为字符串长度），但具体区别如下：

## 时间复杂度对比

| 方法                         | 时间复杂度 | 说明                                 |
| ---------------------------- | ---------- | ------------------------------------ |
| **Method 1: `reverse()`**    | **O(n)**   | Python 内置方法，遍历整个数组反转    |
| **Method 2: `while` 双指针** | **O(n)**   | 两个指针各遍历 n/2 次，共 n/2 次交换 |
| **Method 3: `range` 循环**   | **O(n)**   | 遍历前一半元素（n/2），逐一交换      |

## 实际对比

虽然三者都是 O(n)，但**恒定因子不同**：

```python
# Method 1
s.reverse()  
# 遍历次数：n 次（底层C实现）

# Method 2
while left < right:           # 每次迭代都判断 left < right
    s[left], s[right] = ...
    left += 1
    right -= 1
# 遍历次数：n/2 次，但每次多一个条件判断

# Method 3
for i in range(n // 2):       # range直接生成数字，无条件判断开销
    s[i], s[n-i-1] = ...
# 遍历次数：n/2 次，条件判断少
```

## 推荐方案

**Method 3（range 循环）最优**，原因：
- ✅ 遍历次数少（n/2）
- ✅ 无条件判断开销（range 预先生成所有数字）
- ✅ 代码简洁



# 541: 字符串反转II

好的，我来帮你总结一下。



你刚才讲的题目是关于反转字符串的第二个变形，也就是 LeetCode 541 题。题目要求对给定字符串 S 和一个整数 K，每隔 2K 个字符反转前 K 个字符。如果剩余字符少于 K 个就全部反转；如果剩余字符在 K 到 2K 之间，则反转前 K 个字符，剩下的保持不变。



你用了两种方法。第一种是用 Python 的切片来做反转。因为字符串在 Python 中是不可变的，所以你先把字符串转换成列表，然后用 range 函数每 2K 一步地去切片反转前 K 个字符。最后再把列表转换回字符串。



第二种方法是用双指针（two-pointer）的方法自己实现一个反转子串的函数。你先写一个 reverse_substring 的方法，让左右指针向中间移动并交换字符。然后在主函数里同样遍历每 2K 段去调用这个反转函数，最后再把列表转回字符串。



这个就是你的思路总结。接下来我来给你翻译成英文。



Sure, here’s the English version of what you explained.



So this problem is about the “Reverse String II” challenge, which is LeetCode problem 541. The problem statement gives you a string S and an integer K. You need to reverse the first K characters for every 2K characters counting from the start of the string. If there are fewer than K characters left at the end, you reverse all of them. If there are at least K but less than 2K characters left, you just reverse the first K and leave the rest as is.

There are two approaches. The first approach uses Python slicing. Since strings in Python are immutable, you convert the string into a list to make modifications. You use a loop with range stepping by 2K, and then reverse the first K characters in each segment using slicing. After that, you join the list back into a string.

The second approach is a two-pointer method where you write a helper function to reverse a substring by swapping characters in place with two pointers moving inward. In the main function, you similarly iterate over the string in 2K steps, apply this reverse function to each relevant part, and then convert the list back to a string at the end.

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        # 方法一: 切片反转
        # res = list(s) # str 在python里是不可变的, 所以必须转为可变的列表list, 才能对里面的字符进行修改和交换
        # for i in range(0, len(res), 2*k): # 使用range(start, stop, step) 函数来确定需要调换的初始位置。i的值从索引0开始, 循环到列表末尾结束, 每一次循环, i=0, 2k, 4k,...
        #     res[i: i+k] = res[i:i+k][::-1] # 反转前k个字符后, 更改原值为反转后值. 用切片整体替换, 而不是一个个替换
# res[i:i+k]：取出从位置 i 开始的 k 个字符
# 例如：i=0, k=2 → res[0:2] = ['a', 'b']
# [::-1]：反转切片（Python 反转语法）
# ['a', 'b'][::-1] = ['b', 'a']
# 赋值回原位置：整体替换（不需要逐个交换）
        
        # 方法二: reverse自主实现(two pointer approach)
        def reverse_substring(text: List[str]) -> List[str]:
            left, right = 0, len(text)-1
            while left < right:
                text[left], text[right] = text[right], text[left]
                left += 1
                right -= 1
            return text
        
        res = list(s)
        for i in range(0, len(s), 2*k):
            res[i: i+k] = reverse_substring(res[i: i+k])

        return ''.join(res) # 将 list 转回 str. 用空字符串 '' 作为连接符，将列表 res 中的所有字符连接起来。eg: ['a', 'b', 'c'] -> 'abc'
    
```

很好的问题！**代码已经自动处理了这些边界情况**，但看不出来。让我用具体例子讲解：

## 两个关键点

### 1. Python 切片自动截断
```python
s = "abcdefg"  # 长度 7
res = list(s)

# 当 i=4 时（第 2 组）
res[4:6]   # 取索引 4-5，共 2 个字符 ['e','f']
res[4:6][::-1] = ['f','e']

# 当 i=8 时（超出范围）
range(0, 7, 4) = [0, 4]  # i 不会到 8！循环自动停止
```

### 2. 处理不足 k 个的情况
假设 `s = "abcde", k = 3`：

```
每 6 个字符（2k）处理一次：
- 第 1 组（索引 0-5）：只有 0-4，共 5 个
  - 前 3 个反转：[0:3] = ['a','b','c'] → ['c','b','a']
  - 剩余 2 个保持：[3:5] = ['d','e']

代码执行：
i=0 时：
  res[0:3] = res[0:3][::-1]
  res = ['c','b','a','d','e']

i=6 时：
  6 >= len(res)=5，循环终止 ✓
```

---

## 三个边界情况都被自动处理

| 情况              | 示例             | 代码如何处理                                      |
| ----------------- | ---------------- | ------------------------------------------------- |
| **< k 个字符**    | `"ab", k=3`      | `res[0:3][::-1]` 只取存在的 2 个，反转后变 `"ba"` |
| **k ≤ 字符 < 2k** | `"abcde", k=3`   | `res[0:3]` 反转 3 个，剩余 2 个自动保持           |
| **≥ 2k 个字符**   | `"abcdefg", k=2` | 正常反转每组前 k 个                               |

---

## 完整演示（最清楚的例子）

```python
def reverseStr(s: str, k: int) -> str:
    res = list(s)
    for i in range(0, len(res), 2*k):  # ← 这行已处理所有边界
        res[i:i+k] = res[i:i+k][::-1]  # ← 切片自动截断
    return ''.join(res)

# 测试
print(reverseStr("abcdefg", 2))  # "bacdfeg" ✓
print(reverseStr("abcd", 2))     # "bacd" ✓ (只有 2 个字符，不足 2k)
print(reverseStr("ab", 3))       # "ba" ✓ (只有 2 个字符，不足 k)
```

**关键秘密**：`res[i:i+k]` 当超出范围时，Python **自动截断到实际可用的字符**，无需显式判断！



# 补充题目:卡码网 54. 替换数字

https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html#%E6%80%9D%E8%B7%AF

# 54. 替换数字

[卡码网题目链接(opens new window)](https://kamacoder.com/problempage.php?pid=1064)

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。



这道题的核心思路是**使用“双指针法”从后向前填充**，以此来达到 O(n)的时间复杂度。

虽然 Python 的字符串是不可变的（必须新建一个列表来处理），但这段代码刻意模拟了 C++ 中“原地扩容 + 从后向前替换”的经典算法思想。

下面我为你逐行拆解这段 Python 代码的逻辑：

### 1. 核心思路：为什么要“从后向前”？

如果从前向后填充，每次遇到一个数字插入 "number"，后面的所有字符都要向后移动，这样时间复杂度会变成 O(n^2)。

从后向前填充的好处是：我们可以先算出扩容后的总长度，然后直接把字符放到最终位置，每个字符只处理一次，时间复杂度是 O(n)。

### 2. 代码详解

Python

```python
class Solution(object):
    def subsitute_numbers(self, s):
        # 1. 统计数字个数
        count = sum(1 for char in s if char.isdigit())
        
        # 2. 计算扩容后的新长度
        # 原有的数字占 1 位，"number" 占 6 位，所以每个数字会让总长度增加 5
        expand_len = len(s) + (count * 5)
        
        # 3. 创建一个固定长度的列表（模拟 C++ 的 resize）
        res = [''] * expand_len
        
        # 4. 初始化双指针
        new_index = expand_len - 1  # 指向新数组的末尾
        old_index = len(s) - 1      # 指向原字符串的末尾
        
        # 5. 从后向前遍历
        while old_index >= 0:
            if s[old_index].isdigit():
                # 核心逻辑：如果是数字，直接填入 "number"
                # 切片赋值：从 new_index 往前数 5 位开始，到 new_index 结束
                # 范围是 [new_index - 5, new_index + 1)，正好 6 个位置
                res[new_index - 5 : new_index + 1] = "number"
                new_index -= 6  # 新指针向前跳 6 格
            else:
                # 如果是字母，直接复制过来
                res[new_index] = s[old_index]
                new_index -= 1  # 新指针向前跳 1 格
            
            old_index -= 1  # 旧指针始终向前走 1 格
            
        return "".join(res)
```

### 3. 关键点解析

- res = [''] * expand_len

  这一步是在预先分配内存。虽然 Python 列表是动态的，但为了模拟“双指针从后填充”的逻辑，我们需要一个已经定好长度的容器，这样才能通过下标 res[new_index] 直接写入。

- res[new_index - 5 : new_index + 1] = "number"

  这是 Python 特有的切片赋值。

  - 假设 `new_index` 是 10。
  - `new_index - 5` 是 5。
  - `new_index + 1` 是 11。
  - 切片 `res[5:11]` 包含下标 `5, 6, 7, 8, 9, 10`，正好 6 个位置，被替换为 "n", "u", "m", "b", "e", "r"。
  - 这比手动写 6 行赋值（如 `res[i] = 'r'`, `res[i-1] = 'e'`...）要简洁得多，但逻辑是一样的。

### 总结

这种写法在 Python 中主要用于**练习算法思维**（模拟数组操作）。在实际的 Python 工程开发中，我们通常会直接使用 `replace` 方法，但在面试或算法题中，考察的重点是你是否理解**如何避免数组元素的重复移动**。

没问题！这段代码是用 Python 模拟 C++ 中“**双指针从后向前**”填充数组的经典写法。

--------

对 Python 新手来说，里面有几个“语法糖”（简便写法）可能会让人发懵。我把它拆碎了，用大白话讲给你听。

### 宏观图景：我们在做什么？

假设字符串是 "a1b"，我们要把数字 1 换成 "number"。

结果应该是 "anumberb"。

这段代码的策略是：先算出最终需要多长的坑位，占好坑，然后从最后一位往前填，避免反复移动数据。

------

### 逐行拆解

#### 1. 统计数字个数

Python

```python
count = sum(1 for char in s if char.isdigit())
```

- **翻译**：把字符串 `s` 里的每个字符拿出来看一看（`for char in s`），如果这个字符是数字（`if char.isdigit()`），就算作一个 1。最后把这些 1 加起来（`sum(...)`）。
- **用意**：我们要知道一共有多少个数字，这样才能算出需要扩充多少空间。
- **新手理解**：这就好比数人头，但只数戴帽子的人（数字）。

#### 2. 计算新长度

Python

```
expand_len = len(s) + (count * 5)
```

- **翻译**：新长度 = 原长度 + (数字个数 × 5)。
- **用意**：为什么乘 5？
  - 原来的数字（比如 `'1'`）已经占了 **1** 个坑位。
  - 我们要换成的词是 `"number"`，有 **6** 个字母。
  - 所以每个数字需要**额外增加 5 个坑位**（6 - 1 = 5）。

#### 3. 预先分配“座位”

Python

```
res = [''] * expand_len
```

- **翻译**：创建一个列表，里面有 `expand_len` 这么多全是空字符串 `''` 的元素。
- **用意**：**这是最关键的一步模拟！**
  - Python 的列表虽然可以随时变大，但这里我们假装它是一个固定长度的 C++ 数组。
  - 我们要先把所有的“空椅子”摆好，方便一会儿直接让人坐进去（通过下标赋值），而不是挤进去（append/insert）。

#### 4. 设定两个指针（手指）

Python

```
new_index = expand_len - 1
old_index = len(s) - 1
```

- **翻译**：
  - `new_index`：伸出一根手指，指向**新数组**的最末尾（最后一个空椅子）。
  - `old_index`：伸出另一根手指，指向**原字符串**的最末尾（最后一个字符）。
- **用意**：我们要**倒着走**。就像搬家一样，从旧房子的最后一件家具开始搬，搬到新房子的最后面去。

#### 5. 开始倒着循环

Python

```
while old_index >= 0:
```

- **翻译**：只要旧房子的手指还没指到大门外（索引还没小于 0），就继续搬。

#### 6. 遇到数字怎么办？（核心难点）

Python

```
if s[old_index].isdigit():
    res[new_index - 5 : new_index + 1] = "number"
    new_index -= 6
```

- **翻译**：
  - `if ...`: 如果旧手指指的是个数字。
  - `res[...] = "number"`: **切片赋值**。这是 Python 的魔法。
    - 意思是：在新列表里，从 `new_index` 往前数 5 个位置开始，一直到 `new_index`，这 **6个位置**，直接填入 `"number"` 这 6 个字符。
    - **注意**：`new_index + 1` 是因为 Python 切片是“包头不包尾”的，想取到 `new_index`，必须写到 `+1`。
  - `new_index -= 6`: 既然填进去 6 个字（number），新手指就要往前跳 6 格，准备填下一个。

#### 7. 遇到字母怎么办？

Python

```
else:
    res[new_index] = s[old_index]
    new_index -= 1
```

- **翻译**：如果旧手指指的不是数字（是字母）。
  - 直接把这个字母搬到新手指指的位置。
  - 新手指往前跳 1 格。

#### 8. 旧手指继续走

Python

```
old_index -= 1
```

- **翻译**：不论刚才搬的是数字还是字母，旧房子的这个东西已经处理完了，旧手指往前移一格，看下一个。

#### 9. 变回字符串

Python

```
return "".join(res)
```

- **翻译**：把列表 `res` 里的所有字符用“无缝胶水”（空字符串）粘在一起。
- **用意**：因为我们中间操作的是列表（List），最后题目要求返回字符串（String）。

------

### 总结：为什么要这么写？

如果是在工作中写业务代码，Python 程序员通常直接写：

Python

```
return s.replace("1", "number").replace("2", "number")... # 或者用正则
```

一行搞定。

但你看到的这段代码，是为了**练习算法思维**。它教会你：**“当不能随意开辟新数组，或者插入元素代价很高时，如何通过‘倒序遍历’来高效地完成替换。”** 这是一个通用的编程智慧。



没问题，为了让你更直观地理解每一行代码在做什么，我把原本“浓缩”的写法（比如列表推导式、复杂的切片计算）全部展开，并加上了详细的新手注释。

这份代码保留了**“双指针从后向前填充”**的核心算法逻辑，但写法上更符合直觉，适合打断点调试学习。

Python

```python
class Solution:
    def replace_number(self, s: str) -> str:
        """
        题目：将字符串 s 中的每个数字字符替换为 "number"
        核心思路：先扩容，然后从后向前填充，避免频繁移动元素。
        """
        
        # --- 第一步：统计有多少个数字 ---
        # 原写法：count = sum(1 for char in s if char.isdigit())
        # 新手展开写法：
        digit_count = 0
        for char in s:
            if char.isdigit():
                digit_count += 1
        
        # --- 第二步：计算扩容后的新长度 ---
        # 原字符串长度
        old_length = len(s)
        # 新长度 = 原长度 + (数字个数 * 5)
        # 为什么乘5？因为 "number" 是6个字符，原数字占1个，替换后相当于多占了5个坑位
        new_length = old_length + (digit_count * 5)
        
        # --- 第三步：创建新列表（预先占位） ---
        # Python字符串不可变，所以我们需要一个列表来模拟字符数组
        # 创建一个长度为 new_length 的列表，里面全填上空字符
        res = [''] * new_length
        
        # --- 第四步：定义双指针（核心！） ---
        # old_ptr 指向原字符串的最后一个字符
        old_ptr = old_length - 1
        # new_ptr 指向新列表的最后一个空位
        new_ptr = new_length - 1
        
        # --- 第五步：从后向前遍历 ---
        # 只要原指针没有走到头（>=0），就继续循环
        while old_ptr >= 0:
            # 取出当前旧指针指向的字符
            current_char = s[old_ptr]
            
            if current_char.isdigit():
                # --- 情况A：如果是数字，填入 "number" ---
                
                # 我们需要填入 'n', 'u', 'm', 'b', 'e', 'r' 这6个字
                # 因为是从后往前填，我们可以直接用切片操作
                # 这里的切片范围是：[new_ptr - 5, new_ptr + 1)
                # 举例：如果 new_ptr 是 10，我们要填入下标 5,6,7,8,9,10
                start_pos = new_ptr - 5
                end_pos = new_ptr + 1
                res[start_pos : end_pos] = "number"
                
                # 填完 "number" 后，新指针要向前跳 6 格
                new_ptr -= 6
                
            else:
                # --- 情况B：如果是字母，直接复制过来 ---
                res[new_ptr] = current_char
                
                # 填完字母后，新指针向前走 1 格
                new_ptr -= 1
            
            # --- 无论填的是什么，旧指针都要向前走 1 格，处理下一个字符 ---
            old_ptr -= 1
            
        # --- 第六步：将列表转回字符串并返回 ---
        return "".join(res)

# --- 运行测试代码 ---
if __name__ == "__main__":
    # 实例化解题类
    solution = Solution()
    
    # 模拟输入
    input_str = "a1b2c3"
    print(f"输入字符串: {input_str}")
    
    # 调用函数
    result = solution.replace_number(input_str)
    
    # 输出结果
    print(f"输出结果:   {result}")
    
    # 简单的交互式测试（你可以手动输入测试）
    print("-" * 20)
    user_input = input("请输入带数字的字符串进行测试 (例如 a5b): ")
    if user_input:
        print("转换结果:", solution.replace_number(user_input))
```

### 代码修改点说明（为了新手友好）：

1. **拆解计数逻辑**：把一行写完的 `sum(...)` 拆成了标准的 `for` 循环和 `if` 判断，方便你理解是在数什么。
2. **变量名具体化**：
   - `count` -> `digit_count` (数字的个数)
   - `old_index` -> `old_ptr` (旧指针)
   - `new_index` -> `new_ptr` (新指针)
3. **计算步骤分离**：把切片的起始位置 `new_ptr - 5` 单独提炼成变量 `start_pos`，让你看清楚下标是怎么算的。
4. **增加主函数入口**：加了 `if __name__ == "__main__":` 模块，你可以直接复制这段代码到编辑器里运行，能立刻看到效果。