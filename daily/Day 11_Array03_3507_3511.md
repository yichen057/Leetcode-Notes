# Day 11 两道群主推荐题

# 1. 题3507: 

我来帮你查找 LeetCode 3507 题的信息，然后给你讲解解题思路。我找到了这道题的信息。让我用新手友好的方式给你讲解 **LeetCode 3507: Minimum Pair Removal to Sort Array I**（最少配对删除使数组有序）。

------

## 题目理解

**题目要求**：给你一个数组 `nums`，你可以执行以下操作任意次：

1. 找到**相邻两个数之和最小**的配对
2. 如果有多个这样的配对，选择**最左边**的那个
3. 把这两个数**替换成它们的和**

问：最少需要多少次操作，才能让数组变成**非递减**（每个数 ≥ 前一个数）？

------

## 举个例子 🌰

```
输入: nums = [5, 2, 3, 1]
```

**第一步**：

- 相邻配对的和：(5+2)=7, (2+3)=5, (3+1)=4
- 最小的是 (3,1)=4，合并它们
- 数组变成：[5, 2, 4]

**第二步**：

- 相邻配对的和：(5+2)=7, (2+4)=6
- 最小的是 (2,4)=6，合并它们
- 数组变成：[5, 6]

现在 5 ≤ 6，数组已经非递减了！

**答案：2 次操作**

------

代码:

```python
# # 方法一: 统一写在一个函数里. 
        # 时间复杂度为O(n²). 每轮耗时 = for循环(n) + pop(n) = 2n; 总共最多 n-1 轮, 所以总耗时 = (n-1) × 2n = 2n² - 2n; 用大 O 表示法，忽略常数和低阶项：O(2n² - 2n) = O(n²)
        # 注: for 和 pop 是相加不是取其一，但因为都是 O(n)，最终结果一样。
        #
        # result = 0 # 操作次数初始化为0

        # while True: # 外层 while：最多执行 n-1 次（数组从 n 个元素变成 1 个
        #     # 找最小和的同时, 顺便检查是否有序
        #     min_sum = float('inf') # 最小值的初始化为无穷大
        #     min_idx = 0 # 记录最小和的位置
        #     is_sorted = True

        #     # 一次遍历, 同时做两件事
        #     # 内层 for：每次 O(n)
        #     for i in range(len(nums) - 1): # 注意: 此处i是index, 不是元素, 所以不能用for i in (len(nums) - 1):
        #         if nums [i] > nums [i+1]: # 判断是否是非递减数组的, 如果前面的比后面大，就不是非递减
        #             is_sorted = False #不是非递减数组, 可以找接着找相邻元素的最小和的位置了
        #         # 找相邻元素的最小和
        #         pair_sum = nums[i] + nums[i+1]
        #         if pair_sum < min_sum:
        #             min_sum = pair_sum
        #             min_idx = i
            
        #     # 遍历完所有元素后, 认定该数组是非递减数组, 说明result = 0
        #     if is_sorted:
        #         break

        #     # 找到相邻元素的最小和后, 合并这两个元素为他们的和, 第二个元素作pop移除
        #     nums[min_idx] = min_sum
        #     # pop 操作：从中间删除元素，需要移动后面的元素，也是 O(n)
        #     nums.pop(min_idx + 1)
        #     # 操作次数+1
        #     result += 1
        
        # return result

        # 方法二: 利用辅助函数来检查数组是否为非递减. 时间复杂度：O(n²)，因为每次操作都要遍历数组
        def is_sorted():
            for i in range(len(nums) -1):
                if nums[i] > nums[i + 1]: # 如果前面的比后面大，就不是非递减
                    return False
            return True
        
        ans = 0 # 记录操作次数

        # 只要数组还不是非递减的，就继续操作
        while not is_sorted(): # while第1层：最多 n-1 次. 操作a: is_sorted() 遍历数组，O(n). 
        # for i in range(n): range(n) 不是每轮都重新算; while not is_sorted(): is_sorted() 每轮都要重新调用！所以 is_sorted() 每轮都会执行，它就是 while 循环的一部分
        # 每轮 while 的耗时: 操作a+操作b+操作c = n+n+n= 3n
        # while 执行次数：最坏情况下，每次只合并两个元素，数组长度从 n 变成 1，需要 n-1 次。
        # 总耗时: (n-1) × 3n = 3n² - 3n, 忽略常数 3 和低阶项 -3n：O(3n² - 3n) = O(n²)
            min_sum = float('inf') # 初始化为无穷大
            min_idx = 0 # 记录最小和的位置

            for i in range(len(nums) -1): # 操作b: 遍历数组，O(n)
                pair_sum =nums[i] + nums[i + 1]
                if pair_sum < min_sum:
                    min_sum = pair_sum
                    min_idx = i
                
            # 合并：把 nums[min_idx] 和 nums[min_idx+1] 替换成它们的和
            nums[min_idx] = min_sum
            nums.pop(min_idx + 1) # 删除后面那个元素. 操作c: 删除元素，O(n)

            # 操作次数+1
            ans += 1

        return ans

```





## 解题思路（暴力模拟）

这道题的思路很直接，就是**按照题目说的一步一步做**：

```
while 数组还不是非递减的:
    1. 找到相邻元素和最小的位置
    2. 合并这两个元素
    3. 操作次数 +1
    
返回操作次数
```

------

## Python 代码（带详细注释）

```python
class Solution:
    def minimumPairRemoval(self, nums: list[int]) -> int:
        
        # 辅助函数：检查数组是否非递减
        def is_sorted():
            for i in range(len(nums) - 1):
                if nums[i] > nums[i + 1]:  # 如果前面的比后面大，就不是非递减
                    return False
            return True
        
        ans = 0  # 记录操作次数
        
        # 只要数组还不是非递减的，就继续操作
        while not is_sorted():
            # 找相邻元素和最小的位置
            min_sum = float('inf')  # 初始化为无穷大
            min_idx = 0             # 记录最小和的位置
            
            for i in range(len(nums) - 1):
                pair_sum = nums[i] + nums[i + 1]
                if pair_sum < min_sum:
                    min_sum = pair_sum
                    min_idx = i
            
            # 合并：把 nums[min_idx] 和 nums[min_idx+1] 替换成它们的和
            nums[min_idx] = min_sum
            nums.pop(min_idx + 1)  # 删除后面那个元素
            
            ans += 1
        
        return ans
```

------

## 图解过程

```
原数组: [5, 2, 3, 1]
         ↓
检查: 5>2? ✓ 不是非递减，需要操作

找最小和: 
  5+2=7  2+3=5  3+1=4 ← 最小！
                 ↑
合并后: [5, 2, 4]    操作次数=1
         ↓
检查: 5>2? ✓ 不是非递减

找最小和:
  5+2=7  2+4=6 ← 最小！
          ↑
合并后: [5, 6]       操作次数=2
         ↓
检查: 5≤6? ✓ 是非递减！

返回 2
```

------

## 复杂度分析

- **时间复杂度**：O(n²)，因为每次操作都要遍历数组
- **空间复杂度**：O(n)，存储数组

------

## 关键点总结

| 要点     | 说明                         |
| -------- | ---------------------------- |
| 非递减   | 每个元素 ≥ 它前面的元素      |
| 选择配对 | 和最小 + 最左边              |
| 合并操作 | 两个数变成一个数（它们的和） |
| 终止条件 | 数组变成非递减               |

这道题作为入门题，核心就是**模拟**——题目怎么说，代码就怎么写。理解了这个思路后，你可以尝试进阶版 3510 题，那道题需要更高效的数据结构来优化。

有什么不清楚的地方吗？



什么数据结构可以用pop方法

这是个很好的基础问题！我来给你整理一下常见编程语言中支持 `pop` 方法的数据结构。

------

## Python

| 数据结构              | pop 用法                           | 说明                           |
| --------------------- | ---------------------------------- | ------------------------------ |
| **list（列表）**      | `list.pop()` 或 `list.pop(i)`      | 默认删除最后一个，也可指定索引 |
| **dict（字典）**      | `dict.pop(key)`                    | 删除指定 key 并返回其 value    |
| **set（集合）**       | `set.pop()`                        | 随机删除一个元素               |
| **deque（双端队列）** | `deque.pop()` 或 `deque.popleft()` | 两端都能弹出                   |

```python
# list
nums = [1, 2, 3, 4]
nums.pop()      # 返回 4，nums 变成 [1, 2, 3]
nums.pop(0)     # 返回 1，nums 变成 [2, 3]

# deque（需要 from collections import deque）
from collections import deque
dq = deque([1, 2, 3])
dq.pop()        # 返回 3，从右边弹出
dq.popleft()    # 返回 1，从左边弹出
```

------

## JavaScript

| 数据结构          | pop 用法      | 说明                                 |
| ----------------- | ------------- | ------------------------------------ |
| **Array（数组）** | `arr.pop()`   | 删除并返回最后一个元素               |
| **Array**         | `arr.shift()` | 删除并返回第一个元素（类似 popleft） |

```javascript
let arr = [1, 2, 3, 4];
arr.pop();    // 返回 4
arr.shift();  // 返回 1
```

------

## Java

Java 没有直接叫 `pop` 的通用方法，但有类似功能：

| 数据结构             | 方法                                      | 说明     |
| -------------------- | ----------------------------------------- | -------- |
| **Stack**            | `stack.pop()`                             | 弹出栈顶 |
| **Deque/ArrayDeque** | `deque.pop()` 或 `pollFirst()/pollLast()` | 双端操作 |
| **LinkedList**       | `list.removeLast()`                       | 类似 pop |

```java
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.pop();  // 返回 1
```

------

## C++

| 数据结构   | 方法                         | 说明                       |
| ---------- | ---------------------------- | -------------------------- |
| **vector** | `vec.pop_back()`             | 删除最后一个（无返回值！） |
| **stack**  | `stk.pop()`                  | 弹出栈顶（无返回值！）     |
| **deque**  | `pop_front()` / `pop_back()` | 两端弹出                   |
| **queue**  | `que.pop()`                  | 弹出队首                   |

```cpp
vector<int> vec = {1, 2, 3};
vec.pop_back();  // vec 变成 {1, 2}，注意没有返回值！

// 如果需要获取值，要先取再删
int last = vec.back();
vec.pop_back();
```

------

## 总结

**最常用的支持 pop 的数据结构**：

| 类型                 | 特点          | 适用场景           |
| -------------------- | ------------- | ------------------ |
| **栈 (Stack)**       | 后进先出 LIFO | 括号匹配、递归模拟 |
| **队列 (Queue)**     | 先进先出 FIFO | BFS、任务调度      |
| **双端队列 (Deque)** | 两端都能操作  | 滑动窗口           |
| **列表/数组**        | 灵活操作      | 通用场景           |

在 LeetCode 3507 这道题中，Python 的 `list.pop(index)` 可以删除任意位置的元素，非常方便。但要注意，从中间删除的时间复杂度是 O(n)，不是 O(1)。



你觉得这道题用辅助函数比较好, 还是写在一个函数里比较好呢

这是个很好的代码风格问题！其实两种写法各有优缺点，我来分析一下：

------

## 两种写法对比

**写法一：用辅助函数**

```python
def minimumPairRemoval(self, nums: list[int]) -> int:
    
    def is_sorted():
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                return False
        return True
    
    ans = 0
    while not is_sorted():
        # ... 合并逻辑
        ans += 1
    return ans
```

**写法二：写在一起**

```python
def minimumPairRemoval(self, nums: list[int]) -> int:
    ans = 0
    
    while True:
        # 检查是否有序
        sorted_flag = True
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                sorted_flag = False
                break
        
        if sorted_flag:
            break
            
        # ... 合并逻辑
        ans += 1
    return ans
```

------

## 我的看法

**对于这道题，我更倾向于写在一起**，原因是：

```python
def minimumPairRemoval(self, nums: list[int]) -> int:
    ans = 0
    
    while True:
        # 找最小和的同时，顺便检查是否有序
        min_sum = float('inf')
        min_idx = 0
        is_sorted = True
        
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                is_sorted = False
            pair_sum = nums[i] + nums[i + 1]
            if pair_sum < min_sum:
                min_sum = pair_sum
                min_idx = i
        
        if is_sorted:
            break
        
        nums[min_idx] = min_sum
        nums.pop(min_idx + 1)
        ans += 1
    
    return ans
```

**好处**：一次遍历同时完成两件事，减少重复遍历。

------

## 什么时候用辅助函数更好？

| 场景                       | 建议                     |
| -------------------------- | ------------------------ |
| 逻辑会被**多处调用**       | ✅ 用辅助函数             |
| 逻辑比较**复杂独立**       | ✅ 用辅助函数，提高可读性 |
| 逻辑**简单且只用一次**     | 写在一起也行             |
| 能**合并遍历**减少重复工作 | 写在一起更高效           |

------

## 总结

- **面试/比赛**：效率优先，写在一起减少遍历次数
- **工程代码**：可读性优先，复杂逻辑拆成辅助函数
- **这道题**：因为可以合并遍历，写在一起更优雅

不过说实话，这道题数据量小，两种写法性能差距不大。选择你觉得更清晰的写法就好，代码首先是给人看的。



if is_sorted: break, 为啥这个判断在中间, 而不是最开始

好问题！这其实是一个**循环结构设计**的取舍。

------

## 为什么放中间？

因为我把「检查是否有序」和「找最小配对」**合并到一次遍历**里了：

```python
while True:
    # 一次遍历，同时做两件事
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            is_sorted = False          # 事情1：检查有序
        if pair_sum < min_sum:
            min_sum = pair_sum         # 事情2：找最小配对
            min_idx = i
    
    if is_sorted:                      # 遍历完才知道结果
        break
    
    # 合并操作...
```

遍历完成后才能确定是否有序，所以判断只能放在 for 循环之后。

------

## 如果想放最开始呢？

那就需要**单独遍历一次**来检查：

```python
while True:
    # 先单独检查是否有序
    is_sorted = True
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            is_sorted = False
            break
    
    if is_sorted:                      # 可以放前面了
        break
    
    # 再遍历一次找最小配对
    for i in range(len(nums) - 1):
        if pair_sum < min_sum:
            min_sum = pair_sum
            min_idx = i
    
    # 合并操作...
```

这样每轮循环要遍历**两次**数组。

------

## 对比

| 写法       | 遍历次数 | 代码结构   |
| ---------- | -------- | ---------- |
| 判断放中间 | 1 次     | 稍微不直观 |
| 判断放开头 | 2 次     | 更符合直觉 |

------

## 总结

放中间是为了**省一次遍历**，用一点直观性换效率。

如果你觉得放开头更好理解，那样写也完全没问题，性能差距在这道题里可以忽略。清晰易懂的代码往往比微小的优化更重要。



对于一个函数的写法, 时间复杂度会为n吗?

不会，时间复杂度仍然是 **O(n²)**。

------

## 分析一下

```python
while True:                              # 最多执行 n-1 次（每次数组长度减1）
    for i in range(len(nums) - 1):       # 每次遍历当前数组，O(n)
        # ...
    
    nums.pop(min_idx + 1)                # pop 操作也是 O(n)
```

- **外层 while**：最多执行 n-1 次（数组从 n 个元素变成 1 个）
- **内层 for**：每次 O(n)
- **pop 操作**：从中间删除元素，需要移动后面的元素，也是 O(n)

总时间复杂度：**O(n) × O(n) = O(n²)**

------

## 你可能的疑惑

「合并遍历不是优化了吗？」

是的，但只是把 **2n 变成 n**，常数级别的优化：

| 写法     | 每轮操作 | 总复杂度          |
| -------- | -------- | ----------------- |
| 两次遍历 | 2n       | O(2n × n) = O(n²) |
| 合并遍历 | n        | O(n × n) = O(n²)  |

大 O 表示法忽略常数，所以都是 O(n²)。

------

## 想要真正的 O(n) 或 O(n log n)？

那需要完全不同的数据结构，比如：

- **链表**：删除操作 O(1)
- **堆/优先队列**：快速找最小值 O(log n)
- **有序集合 (TreeSet)**：维护有序性

这就是进阶版 **LeetCode 3510** 的思路了，需要用更复杂的数据结构来优化。





- 外层 while：最多执行 n-1 次（数组从 n 个元素变成 1 个）
- 内层 for：每次 O(n)
- pop 操作：从中间删除元素，需要移动后面的元素，也是 O(n) 在计算时间复杂度的时候, 内层for和pop都是n, 外层while是n-1, 所以n*(n-1)=O(n²), 是这样计算的吗

差不多是这个意思，但更准确一点：

------

## 详细计算

每一轮 while 循环里有两个 O(n) 的操作：

```
每轮耗时 = for循环(n) + pop(n) = 2n
```

总共最多 n-1 轮：

```
总耗时 = (n-1) × 2n = 2n² - 2n
```

用大 O 表示法，**忽略常数和低阶项**：

```
O(2n² - 2n) = O(n²)
```

------

## 你的理解对不对？

基本正确！只是小细节：

| 你的理解          | 更准确的说法            |
| ----------------- | ----------------------- |
| n × (n-1) = O(n²) | (n-1) × (n + n) = O(n²) |

for 和 pop 是**相加**不是取其一，但因为都是 O(n)，最终结果一样。

------

## 简化记忆

实际分析复杂度时，常用的思路是：

```
外层循环次数 × 内层最耗时的操作 = 总复杂度
```

这道题：

- 外层：O(n) 次
- 内层：O(n)（for 和 pop 都是 n，取最大的）

所以 **O(n) × O(n) = O(n²)**

这样算虽然不那么精确，但结果是对的，面试时也够用。

来一步步分析这段代码的时间复杂度。

------

## 逐层分析

```python
while not is_sorted():          # 第1层：最多 n-1 次
    
    is_sorted()                 # 操作A：遍历数组，O(n)
    
    for i in range(len(nums)-1) # 操作B：遍历数组，O(n)
        ...
    
    nums.pop(min_idx + 1)       # 操作C：删除元素，O(n)
```

------

## 计算过程

**每轮 while 的耗时：**

```
操作A + 操作B + 操作C = n + n + n = 3n
```

**while 执行次数：**

最坏情况下，每次只合并两个元素，数组长度从 n 变成 1，需要 n-1 次。

**总耗时：**

```
(n-1) × 3n = 3n² - 3n
```

------

## 大 O 表示法

忽略常数 3 和低阶项 -3n：

```
O(3n² - 3n) = O(n²)
```

------

## 总结

| 部分        | 复杂度    | 说明           |
| ----------- | --------- | -------------- |
| is_sorted() | O(n)      | 遍历一次数组   |
| for 循环    | O(n)      | 遍历一次数组   |
| pop         | O(n)      | 移动后面的元素 |
| while 次数  | O(n)      | 最多 n-1 轮    |
| **总计**    | **O(n²)** | n × (n+n+n)    |

所以这个写法的时间复杂度是 **O(n²)**，和合并遍历的写法一样，只是常数大一点（3n vs 2n），实际运行会稍慢，但量级相同。



is_sorted()作为操作a, 这个也不在while循环里, 为啥也要加在操作b+操作c里呢?

其实 `is_sorted()` 是在 while 循环里的！

------

## 看清楚 while 的结构

```python
while not is_sorted():    # ← is_sorted() 在这里被调用！
    for i in range(...):
        ...
    nums.pop(...)
```

**每次循环开始时**，都要先执行 `is_sorted()` 来判断条件是否成立。

------

## 执行流程

```
第1轮: is_sorted() → for循环 → pop
第2轮: is_sorted() → for循环 → pop
第3轮: is_sorted() → for循环 → pop
...
最后:  is_sorted() → 返回True，退出循环
```

所以 `is_sorted()` 每轮都会执行，它就是 while 循环的**一部分**。

------

## 对比 for 循环就更清楚了

```python
for i in range(n):    # range(n) 不是每轮都重新算
    ...

while not is_sorted():  # is_sorted() 每轮都要重新调用！
    ...
```

while 的条件**每次都会重新计算**，这和 for 循环不一样。

------

所以计算复杂度时，`is_sorted()` 的 O(n) 必须算进每轮 while 的耗时里。



# LeetCode 3511: Make a Positive Array（使数组变为正数组）

## 题目理解

**题目要求**：

- 给你一个数组 `nums`
- 一个数组被称为「正数组」，当且仅当**所有长度超过 2 的子数组的和都是正数**
- 你可以把任意一个元素替换成任意整数
- 问：**最少需要多少次替换操作**？

**关键点**：只关心长度 ≥ 3 的子数组！

------

## 举例说明 🌰

**例子 1**：`nums = [-10, 15, -12]`

唯一长度 > 2 的子数组就是整个数组，和为 -10 + 15 + (-12) = -7 ≤ 0 ❌

把 -10 改成 0 后：0 + 15 + (-12) = 3 > 0 ✅

答案：**1 次操作**

**例子 2**：`nums = [1, 2, 3]`

整个数组和 = 6 > 0 ✅，已经满足条件

答案：**0 次操作**

------

## 核心思路

这道题的关键洞察是：

> **如果我们修改了某个位置的元素，那么这个元素可以变成任意大的正数，足以让包含它的所有子数组的和变成正数。**

所以问题变成了：**最少修改多少个元素，使得每个长度 ≥ 3 的子数组至少包含一个被修改的元素？**

------

## 贪心策略

我们用**贪心 + 滑动窗口**的思想：

1. 从左到右遍历数组
2. 维护一个「安全区间」`[l+1, r]`，表示这段区间内的子数组都满足条件
3. 当发现某个长度 ≥ 3 的子数组和 ≤ 0 时，必须做一次修改
4. 修改后，重新开始一个新的区间

------

好的，根据我们讨论的内容，写一个带详细注释的代码：

```python
class Solution:
    def makeArrayPositive(self, nums: List[int]) -> int:
        """
        题目要求：所有长度 ≥ 3 的子数组的和都必须是正数
        操作：可以把任意元素改成任意值
        目标：最少需要多少次操作
        
        核心思路：
        - 从左到右遍历，维护一个「安全区间」[l+1, r]
        - 检查以 r 结尾、长度 ≥ 3 的子数组是否有和 ≤ 0 的
        - 如果有，就在位置 r 做修改，然后重新开始
        """
        
        l = -1      # 上一次修改的位置（初始为 -1，表示还没修改过）
                    # 当前安全区间是 [l+1, r]
        
        ans = 0     # 记录操作次数
        
        s = 0       # 当前区间 [l+1, r] 的总和
        
        pre_mx = 0  # 区间 [l+1, r-2] 内所有前缀和的最大值
                    # 初始为 0，因为空前缀的和是 0
                    # 用途：快速判断是否存在和 ≤ 0 的子数组
        
        for r, x in enumerate(nums):
            # x = nums[r]，当前遍历到的元素
            
            s += x  # 更新区间和，现在 s = sum[l+1, r]
            
            # ============ 条件1：检查是否需要修改 ============
            # r - l > 2：区间长度 > 2，才可能有长度 ≥ 3 的子数组
            # s <= pre_mx：存在某个前缀和 prefix[i-1] >= s
            #              即 s - prefix[i-1] <= 0
            #              即子数组 [i, r] 的和 <= 0
            if r - l > 2 and s <= pre_mx:
                ans += 1          # 需要修改一个元素
                l = r             # 在位置 r 做修改，重新开始新区间
                pre_mx = s = 0    # 重置状态（新区间从 r+1 开始算）
            
            # ============ 条件2：更新 pre_mx ============
            # r - l >= 2：区间长度 >= 2 时才需要更新
            # 注意：这个 elif 保证了条件1不满足时才执行
            elif r - l >= 2:
                # s - x - nums[r-1] 是什么？
                # s              = sum[l+1, r]     整个区间的和
                # s - x          = sum[l+1, r-1]   去掉最后一个元素
                # s - x - nums[r-1] = sum[l+1, r-2] 去掉最后两个元素
                # 
                # 这就是「到位置 r-2 的前缀和」
                # 因为子数组 [i, r] 长度 ≥ 3 要求 i ≤ r-2
                # 所以 pre_mx 只记录到 r-2 的前缀和
                pre_mx = max(pre_mx, s - x - nums[r - 1])
        
        return ans
```

------

## 代码执行流程示例

```python
输入: nums = [-1, -2, 3, -1, 2, 6]

初始: l=-1, ans=0, s=0, pre_mx=0

r=0, x=-1: s=-1, 区间长度=1, 跳过
r=1, x=-2: s=-3, 区间长度=2, 跳过
r=2, x=3:  s=0,  区间长度=3
           检查: 3>2 ✓ 且 0<=0 ✓ → 需要修改！
           ans=1, l=2, s=0, pre_mx=0

r=3, x=-1: s=-1, 区间长度=1, 跳过
r=4, x=2:  s=1,  区间长度=2, 跳过
r=5, x=6:  s=7,  区间长度=3
           检查: 3>2 ✓ 但 7<=0? ✗ → 不需要修改
           更新 pre_mx = max(0, 7-6-2) = max(0,-1) = 0

返回 ans = 1
```



## 代码详解（Python）

```python
class Solution:
    def makeArrayPositive(self, nums: List[int]) -> int:
        l = -1           # 上一个被修改的位置（虚拟起点为 -1）
        ans = 0          # 操作次数
        pre_mx = 0       # 区间 [l+1, r-2] 的最大前缀和
        s = 0            # 当前区间 [l+1, r] 的总和
        
        for r, x in enumerate(nums):
            s += x       # 累加当前元素
            
            # 条件1：区间长度 > 2，且当前和 ≤ 某个前缀和
            # 说明存在一个长度 ≥ 3 的子数组和 ≤ 0
            if r - l > 2 and s <= pre_mx:
                ans += 1          # 需要修改一个元素
                l = r             # 在位置 r 做修改，重新开始
                pre_mx = s = 0    # 重置状态
            
            # 条件2：区间长度 ≥ 2，更新 pre_mx
            elif r - l >= 2:
                # pre_mx 记录的是到 r-2 位置的最大前缀和
                pre_mx = max(pre_mx, s - x - nums[r - 1])
        
        return ans
```

------



条件1和条件2不能换顺序。

------

## 原因分析

这两个条件是**互斥**的，用的是 `if ... elif`：

```python
if r - l > 2 and s <= pre_mx:    # 条件1：需要修改
    ...
elif r - l >= 2:                  # 条件2：更新 pre_mx
    ...
```

------

## 如果换顺序会怎样？

```python
# 错误的顺序
if r - l >= 2:                    # 先更新 pre_mx
    pre_mx = max(pre_mx, s - x - nums[r - 1])
elif r - l > 2 and s <= pre_mx:   # 再检查是否需要修改
    ans += 1
    l = r
    pre_mx = s = 0
```

**问题**：当 `r - l > 2` 时，两个条件都可能满足！

```
r - l > 2 满足时，r - l >= 2 也一定满足
```

如果先执行条件2，就会**跳过条件1**，漏掉需要修改的情况。

------

## 举个例子

假设当前状态：

```
r - l = 3 (> 2)
s = 5
pre_mx = 10
```

**正确顺序**：

```python
if r - l > 2 and s <= pre_mx:   # 3 > 2 ✓ 且 5 <= 10 ✓
    ans += 1                     # 执行修改 ✓
```

**错误顺序**：

```python
if r - l >= 2:                   # 3 >= 2 ✓
    pre_mx = max(...)            # 只更新了 pre_mx
                                 # 漏掉了修改！✗
```

------

## 总结

| 顺序             | 结果                         |
| ---------------- | ---------------------------- |
| 先条件1，后条件2 | ✓ 正确，先检查是否需要修改   |
| 先条件2，后条件1 | ✗ 错误，会漏掉需要修改的情况 |

**原则**：把更严格/更重要的条件放前面。



## 思路图解

```
数组: [-1, -2, 3, -1, 2, 6]
       0   1  2   3  4  5

遍历过程:
r=0: s=-1, 区间长度=1, 跳过
r=1: s=-3, 区间长度=2, 跳过
r=2: s=0,  区间长度=3, pre_mx=0, s<=pre_mx? 0<=0 是! 
     → 需要修改! ans=1, 在 r=2 处修改, 重置

修改后相当于把 nums[2] 改成一个很大的数
之后的子数组都会因为包含这个大数而满足条件

继续遍历...最终 ans=1
```

------

## 为什么这个贪心是对的？

关键观察：

1. **子数组和 ≤ 0** 的判断等价于：`s - prefix[i] ≤ 0`，即 `s ≤ prefix[i]`
2. 我们只需要检查 `s ≤ pre_mx`（前缀和的最大值）
3. 一旦需要修改，**修改当前位置**是最优的，因为它能「覆盖」最多的未来子数组

------

## 复杂度分析

| 复杂度 | 值   | 说明           |
| ------ | ---- | -------------- |
| 时间   | O(n) | 只遍历一次数组 |
| 空间   | O(1) | 只用了几个变量 |

------

## 对新手的建议

这道题难度较高（属于 Medium 偏难或 Hard），核心难点在于：

1. **理解问题转化**：从「所有子数组和为正」转化为「修改尽量少的元素覆盖所有违规子数组」
2. **贪心策略的正确性**：为什么修改当前位置最优？
3. **前缀和技巧**：用 `s` 和 `pre_mx` 来高效判断是否存在和 ≤ 0 的子数组

如果这道题感觉太难，建议先练习这些前置题目：

- LeetCode 53: Maximum Subarray（最大子数组和）
- LeetCode 560: Subarray Sum Equals K（前缀和基础）
- LeetCode 1423: Maximum Points You Can Obtain from Cards（滑动窗口）

有什么不清楚的地方吗？



好问题！让我来详细解释这些变量的含义。

------

## 1. 变量含义

| 变量     | 含义                                          |
| -------- | --------------------------------------------- |
| `l`      | 上一次修改的位置（初始为 -1，表示还没修改过） |
| `l+1`    | 当前「安全区间」的起点                        |
| `r`      | 当前遍历到的位置（安全区间的终点）            |
| `s`      | 从 `l+1` 到 `r` 的元素之和                    |
| `pre_mx` | 从 `l+1` 到 `r-2` 的所有前缀和中的最大值      |

**为什么是 `l+1`？**

因为 `l` 是上一次修改的位置。修改后的元素可以变成任意大的数，所以从 `l+1` 开始重新计算才有意义。

------

## 2. 详细图解

```
数组: [-1, -2, 3, -1, 2, 6]
索引:   0   1  2   3  4  5
```

初始状态：`l = -1`，`s = 0`，`pre_mx = 0`，`ans = 0`

------

### r = 0

```
当前区间: [l+1, r] = [0, 0]
          [-1]
           ↑r

s = 0 + (-1) = -1
区间长度 = r - l = 0 - (-1) = 1

长度才 1，不用检查（题目只关心长度 ≥ 3 的子数组）
```

------

### r = 1

```
当前区间: [0, 1]
          [-1, -2]
               ↑r

s = -1 + (-2) = -3
区间长度 = 1 - (-1) = 2

长度才 2，还是不用检查
```

------

### r = 2

```
当前区间: [0, 2]
          [-1, -2, 3]
                   ↑r

s = -3 + 3 = 0
区间长度 = 2 - (-1) = 3  ✓ 终于够长了！

现在要检查：这个区间里有没有长度≥3的子数组和 ≤ 0？
```

**检查逻辑**：

```
子数组 [0,2] 的和 = s = 0

条件: r - l > 2 且 s <= pre_mx
      3 > 2 ✓ 且 0 <= 0 ✓

说明存在问题子数组！需要修改！
```

**执行修改**：

```
ans = 1（操作次数 +1）
l = r = 2（记录修改位置）
s = 0（重置）
pre_mx = 0（重置）
```

意思是：我们把 `nums[2]` 改成一个超级大的数，这样包含它的子数组和肯定是正的。

------

### r = 3

```
上次修改位置 l = 2
当前区间: [l+1, r] = [3, 3]
          [..., 修改过, -1]
                       ↑r

s = 0 + (-1) = -1
区间长度 = 3 - 2 = 1

长度才 1，不检查
```

------

### r = 4

```
当前区间: [3, 4]
          [-1, 2]
               ↑r

s = -1 + 2 = 1
区间长度 = 4 - 2 = 2

长度才 2，不检查
```

------

### r = 5

```
当前区间: [3, 5]
          [-1, 2, 6]
                   ↑r

s = 1 + 6 = 7
区间长度 = 5 - 2 = 3 ✓ 够长了

检查: r - l > 2? → 3 > 2 ✓
      s <= pre_mx? → 7 <= 0? ✗

不满足条件，不需要修改！

但要更新 pre_mx:
pre_mx = max(0, s - x - nums[r-1])
       = max(0, 7 - 6 - 2)
       = max(0, -1)
       = 0
```

------

### 遍历结束

**最终答案：`ans = 1`**

------

## 3. 为什么要用 `pre_mx`？

这是为了快速判断「是否存在和 ≤ 0 的子数组」。

对于区间 `[l+1, r]` 里的任意子数组 `[i, r]`（长度 ≥ 3），它的和等于：

```
sum[i, r] = s - prefix[i-1]
```

如果 `sum[i, r] ≤ 0`，即 `s ≤ prefix[i-1]`

所以只要 `s ≤ pre_mx`（前缀和的最大值），就说明存在问题子数组。

------

## 4. 总结图

```
修改前:
[-1, -2, 3, -1, 2, 6]
 ←——————→
 这段有问题，和=0

修改后（把 3 改成很大的数 X）:
[-1, -2, X, -1, 2, 6]
         ↑
      修改点

现在任何包含 X 的子数组和都是正的 ✓
后面 [-1, 2, 6] 和=7>0，本来就没问题 ✓
```

还有什么不清楚的吗？



好问题！这里确实需要仔细理解。

------

## 为什么是 `r-2` 而不是 `r-1`？

因为题目要求**长度 ≥ 3** 的子数组！

------

## 详细解释

假设当前区间是 `[l+1, r]`，我们要检查所有**长度 ≥ 3** 的子数组 `[i, r]`。

```
区间: [l+1, ..., i, ..., r-2, r-1, r]
       ↑              ↑          ↑
      起点         最远的i      终点
```

子数组 `[i, r]` 的长度 = `r - i + 1 ≥ 3`

解这个不等式：`i ≤ r - 2`

所以 `i` 最大只能是 `r-2`！

------

## 举个例子

```
索引:    0    1    2    3    4
数组:   [a,   b,   c,   d,   e]
                             ↑r=4
```

以 `r=4` 结尾、长度 ≥ 3 的子数组有哪些？

| 子数组          | 起点 i | 长度 |
| --------------- | ------ | ---- |
| [c, d, e]       | i=2    | 3 ✓  |
| [b, c, d, e]    | i=1    | 4 ✓  |
| [a, b, c, d, e] | i=0    | 5 ✓  |

注意：`[d, e]` (i=3) 长度只有 2，**不算**！

所以 `i` 的范围是 `[l+1, r-2]`，不包括 `r-1`。

------

## 和前缀和的关系

子数组 `[i, r]` 的和：

```
sum[i, r] = s - prefix[i-1]
```

其中：

- `s` = 整个区间 `[l+1, r]` 的和
- `prefix[i-1]` = 区间 `[l+1, i-1]` 的和

我们要检查是否存在 `sum[i, r] ≤ 0`，即：

```
s - prefix[i-1] ≤ 0
s ≤ prefix[i-1]
```

因为 `i` 的范围是 `[l+1, r-2]`，所以 `i-1` 的范围是 `[l, r-3]`。

但代码里用 `pre_mx` 记录的是**到 `r-2` 位置的前缀和**，稍微有点不同的表述方式，本质是一样的：**只考虑能形成长度 ≥ 3 子数组的那些前缀**。

------

## 代码对应

```python
elif r - l >= 2:
    pre_mx = max(pre_mx, s - x - nums[r - 1])
```

`s - x - nums[r-1]` 是什么？

```
s           = sum[l+1, r]     # 整个区间的和
x           = nums[r]         # 最后一个元素
nums[r-1]   = nums[r-1]       # 倒数第二个元素

s - x - nums[r-1] = sum[l+1, r-2]  # 去掉最后两个元素
```

这就是到位置 `r-2` 的前缀和！

------

## 图示

```
区间: [l+1, ..., r-2, r-1, r]
       ←—————————→  ←——————→
       这部分的和     最后两个
       = pre_mx      元素

s = pre_mx部分 + nums[r-1] + nums[r]

所以:
pre_mx部分 = s - nums[r-1] - nums[r]
           = s - nums[r-1] - x
```

------

## 总结

| 为什么是 r-2 | 原因                                      |
| ------------ | ----------------------------------------- |
| 题目要求     | 只关心长度 ≥ 3 的子数组                   |
| 数学推导     | 子数组 `[i, r]` 长度 ≥ 3 → i ≤ r-2        |
| 代码实现     | `s - x - nums[r-1]` 刚好是到 r-2 的前缀和 |



好的，让我从头解释 `pre_mx` 到底是什么。

------

## pre_mx 的含义

`pre_mx` = 当前安全区间内，**所有前缀和的最大值**

------

## 举个具体例子

```
假设当前安全区间是 [0, 4]
数组: [2, -3, 1, -2, 5]
索引:  0   1  2   3  4
                      ↑r
```

这个区间的**所有前缀**是：

| 前缀   | 元素              | 前缀和 |
| ------ | ----------------- | ------ |
| [0, 0] | [2]               | 2      |
| [0, 1] | [2, -3]           | -1     |
| [0, 2] | [2, -3, 1]        | 0      |
| [0, 3] | [2, -3, 1, -2]    | -2     |
| [0, 4] | [2, -3, 1, -2, 5] | 3      |

`pre_mx` = 这些前缀和里的最大值 = **max(2, -1, 0, -2, 3) = 3**

------

## 为什么需要 pre_mx？

我们要判断：**是否存在一个以 r 结尾、长度 ≥ 3 的子数组，和 ≤ 0？**

子数组 `[i, r]` 的和可以这样算：

```
sum[i, r] = 总和 s - 前缀和[0, i-1]
```

如果 `sum[i, r] ≤ 0`，那么：

```
s - 前缀和[0, i-1] ≤ 0
s ≤ 前缀和[0, i-1]
```

**关键洞察**：只要 `s ≤ 某个前缀和`，就说明存在问题子数组。

所以我们只需要记录**前缀和的最大值** `pre_mx`，然后检查 `s ≤ pre_mx` 就行了！

------

## 图示

```
数组: [2, -3, 1, -2, 5]
       ←——前缀——→    ↑
                    r

s = 整个区间的和 = 3
pre_mx = 最大前缀和 = 2（只算到 r-2 的前缀）

子数组 [i, r] 的和 = s - prefix[i-1]

如果 s ≤ pre_mx，说明存在某个 prefix[i-1] ≥ s
那么 s - prefix[i-1] ≤ 0，即存在和 ≤ 0 的子数组！
```

------

## 为什么只算到 r-2？

因为题目要求长度 ≥ 3：

```
数组: [a, b, c, d, e]
       0  1  2  3  4
                   ↑r=4

以 r=4 结尾、长度≥3 的子数组:
[c,d,e]    起点 i=2
[b,c,d,e]  起点 i=1
[a,b,c,d,e] 起点 i=0

起点最大是 i=2 = r-2
```

所以 `pre_mx` 只记录到位置 `r-2` 的前缀和最大值。

------

## 总结

| 变量     | 含义                     | 作用                            |
| -------- | ------------------------ | ------------------------------- |
| `s`      | 整个区间 `[l+1, r]` 的和 | 用来计算子数组和                |
| `pre_mx` | 区间内前缀和的最大值     | 快速判断是否存在和 ≤ 0 的子数组 |

**判断条件**：`s ≤ pre_mx` → 存在问题子数组 → 需要修改

这样我们不用枚举所有子数组，一个比较就搞定了！



是的！你理解得很对，就是为了**控制区间**，避免重复检查。

------

## 为什么只检查「以 r 结尾」的子数组？

因为我们是**从左到右遍历**的，采用的是**增量检查**的思想：

```
r=0: 检查以 0 结尾的子数组
r=1: 检查以 1 结尾的子数组
r=2: 检查以 2 结尾的子数组
...
```

每次 r 往右移动一格，**新产生的子数组**都是以 r 结尾的。

------

## 举例说明

```
数组: [a, b, c, d, e]
索引:  0  1  2  3  4
```

**当 r=2 时**，长度 ≥ 3 且以 r 结尾的子数组：

```
[a, b, c]  ✓ 新产生的，需要检查
```

**当 r=3 时**，长度 ≥ 3 且以 r 结尾的子数组：

```
[a, b, c, d]  ✓ 新产生的
[b, c, d]     ✓ 新产生的
```

**当 r=4 时**，长度 ≥ 3 且以 r 结尾的子数组：

```
[a, b, c, d, e]  ✓ 新产生的
[b, c, d, e]     ✓ 新产生的
[c, d, e]        ✓ 新产生的
```

------

## 如果不加「以 r 结尾」会怎样？

每次都检查**所有**长度 ≥ 3 的子数组，会重复检查：

```
r=3 时检查: [a,b,c], [a,b,c,d], [b,c,d]
r=4 时检查: [a,b,c], [a,b,c,d], [b,c,d], [a,b,c,d,e], ...
            ↑        ↑          ↑
            这些已经检查过了！重复了！
```

------

## 总结

| 策略              | 检查范围       | 效率         |
| ----------------- | -------------- | ------------ |
| 检查所有子数组    | 每次都检查全部 | O(n²) 或更差 |
| 只检查以 r 结尾的 | 只检查新产生的 | O(n) ✓       |

**核心思想**：

- 以前检查过的子数组，要么已经满足条件，要么已经做了修改
- 每次只需要检查**新加入的元素带来的新子数组**
- 这就是为什么只看「以 r 结尾」的子数组

这是一种很常见的**滑动窗口/增量更新**技巧！



 好的，让我详细解释这个计算。

------

## 变量回顾

在 r=5 时：

| 变量        | 值   | 含义                            |
| ----------- | ---- | ------------------------------- |
| `s`         | 7    | 当前区间 [3, 5] 的总和          |
| `x`         | 6    | `nums[r]` = `nums[5]`，当前元素 |
| `nums[r-1]` | 2    | `nums[4]`，前一个元素           |

------

## `s - x - nums[r-1]` 是什么？

就是**去掉最后两个元素后的和**：

```
当前区间: [l+1, r] = [3, 5]

nums:    [-1,  2,  6]
索引:      3   4   5
          ↑       ↑
         l+1      r

s = (-1) + 2 + 6 = 7      ← 整个区间的和

s - x - nums[r-1] 
= 7 - 6 - 2 
= -1                       ← 去掉最后两个元素后的和
= nums[3] 
= -1 ✓
```

------

## 图示

```
区间: [-1,   2,   6  ]
       ↑    ↑    ↑
       3    4    5
      r-2  r-1   r

s              = (-1) + 2 + 6 = 7   ← 整个区间
s - x          = (-1) + 2     = 1   ← 去掉最后一个
s - x - nums[r-1] = (-1)      = -1  ← 去掉最后两个
```

所以 `s - x - nums[r-1]` 就是**到位置 r-2 的前缀和**！

------

## 为什么要算这个？

记住：`pre_mx` 存的是「到 r-2 位置的前缀和的最大值」

每次 r 往右移动，新增了一个前缀（到新的 r-2 位置），需要更新 `pre_mx`：

```
r=5 之前: pre_mx 记录的是到位置 3 之前的前缀和最大值
r=5 时:   需要把「到位置 3 的前缀和」也考虑进去

到位置 3 的前缀和 = s - x - nums[r-1] = -1

pre_mx = max(旧的 pre_mx, 新的前缀和)
       = max(0, -1)
       = 0
```

------

## 换个角度理解

```python
s - x - nums[r-1]
```

可以拆解为：

```
s                 # 从 l+1 到 r 的和
- x               # 减去 nums[r]
- nums[r-1]       # 减去 nums[r-1]
= 从 l+1 到 r-2 的和
```

这样就得到了**新的前缀和**，用来更新 `pre_mx`。

------

## 总结

| 表达式              | 含义                 |
| ------------------- | -------------------- |
| `s`                 | 区间 [l+1, r] 的和   |
| `s - x`             | 区间 [l+1, r-1] 的和 |
| `s - x - nums[r-1]` | 区间 [l+1, r-2] 的和 |

`pre_mx` 需要记录到 r-2 的前缀和最大值，所以每次用 `s - x - nums[r-1]` 来更新它。



让我重新解释为什么是 `r-2`。

------

## 回到题目要求

题目说：**长度 ≥ 3** 的子数组的和必须是正数。

------

## 以 r 结尾的子数组

假设我们要检查所有**以 r 结尾、长度 ≥ 3** 的子数组 `[i, r]`：

```
子数组长度 = r - i + 1 ≥ 3
```

解这个不等式：

```
r - i + 1 ≥ 3
r - i ≥ 2
i ≤ r - 2
```

所以起点 `i` 的范围是：`l+1 ≤ i ≤ r-2`

------

## 举个具体例子

```
数组: [a, b, c, d, e]
索引:  0  1  2  3  4
                   ↑ r=4
```

以 r=4 结尾、长度 ≥ 3 的子数组有哪些？

| 起点 i | 子数组          | 长度         |
| ------ | --------------- | ------------ |
| i=0    | [a, b, c, d, e] | 5 ✓          |
| i=1    | [b, c, d, e]    | 4 ✓          |
| i=2    | [c, d, e]       | 3 ✓          |
| i=3    | [d, e]          | 2 ✗ 太短了！ |
| i=4    | [e]             | 1 ✗ 太短了！ |

**i 最大只能是 2 = r-2！**

------

## 子数组和怎么算？

子数组 `[i, r]` 的和：

```
sum[i, r] = s - prefix[l+1, i-1]
          = 总和 - 前面那部分的和
数组:  [a,   b,   c,   d,   e]
        ←前缀→   ←—子数组[i,r]—→
       [l+1,i-1] [i,        r]
```

------

## 为什么 pre_mx 算到 r-2？

因为 `i` 最大是 `r-2`，所以 `i-1` 最大是 `r-3`。

但代码里为了方便，`pre_mx` 记录的是**到 r-2 位置**的前缀和：

```
当 i = r-2 时（最短的合法子数组）:
prefix[l+1, i-1] = prefix[l+1, r-3]

但代码更新时机是每次 r 移动后，
实际存的是上一轮的「到 r-2」的前缀和
```

------

## 更直观的理解

```
数组:  [..., r-2, r-1, r]
             ↑     ↑   ↑
             │     └───┴── 这两个必须在子数组里
             │
             └── 起点最远到这里（才能保证长度≥3）
```

如果起点超过 r-2（比如 r-1），那子数组就只有 `[r-1, r]`，长度才 2，不满足 ≥ 3 的要求。

------

## 总结

| 问题                     | 答案                                               |
| ------------------------ | -------------------------------------------------- |
| 为什么是 r-2？           | 因为子数组 `[i, r]` 长度 ≥ 3，要求 i ≤ r-2         |
| r-2 代表什么？           | 能作为合法子数组起点的**最右边位置**               |
| 为什么 pre_mx 算到 r-2？ | 因为只有起点在 [l+1, r-2] 范围内的子数组才需要检查 |



好的，让我统一用 `[i, r]` 来重新解释。

------

## 变量含义

| 变量          | 含义                                       |
| ------------- | ------------------------------------------ |
| `s`           | 从 `l+1` 到 `r` 的总和                     |
| `prefix[i-1]` | 从 `l+1` 到 `i-1` 的和（子数组前面那部分） |

------

## 图示

```
区间:  [l+1, ..., i-1, i, ..., r]
        ←—prefix[i-1]—→←—子数组[i,r]—→
        ←—————————s——————————————→
```

------

## 子数组 `[i, r]` 的和怎么算？

```
sum[i, r] = s - prefix[i-1]
          = 总和 - 前面那部分的和
```

------

## 举个具体例子

```
数组:  [2, -3, 1, -2, 5]
索引:   0   1  2   3  4
        ↑              ↑
       l+1=0           r=4

s = 2 + (-3) + 1 + (-2) + 5 = 3  ← 整个区间的和
```

以 r=4 结尾、长度 ≥ 3 的子数组（即 i ≤ r-2 = 2）：

| 子数组 [i, r] | i    | prefix[i-1]    | sum[i, r] = s - prefix[i-1] |
| ------------- | ---- | -------------- | --------------------------- |
| [0, 4]        | 0    | 0（空）        | 3 - 0 = 3                   |
| [1, 4]        | 1    | prefix[0] = 2  | 3 - 2 = 1                   |
| [2, 4]        | 2    | prefix[1] = -1 | 3 - (-1) = 4                |

------

## 判断逻辑

我们要检查：是否存在 `sum[i, r] ≤ 0`？

```
sum[i, r] ≤ 0
s - prefix[i-1] ≤ 0
s ≤ prefix[i-1]
```

如果 `s ≤ prefix[i-1]` 对某个 `i` 成立，就说明存在问题子数组。

------

## pre_mx 的作用

记录所有 `prefix[i-1]` 的最大值：

```
pre_mx = max(所有的 prefix[i-1])
```

然后只需要判断：

```
s ≤ pre_mx ?
```

- **是** → 存在和 ≤ 0 的子数组 → 需要修改
- **否** → 所有子数组和都是正的 → 没问题

------

## 总结

| 概念              | 含义                      |
| ----------------- | ------------------------- |
| `s`               | 整个区间 [l+1, r] 的和    |
| `prefix[i-1]`     | 区间 [l+1, i-1] 的和      |
| `s - prefix[i-1]` | 子数组 [i, r] 的和        |
| `pre_mx`          | 所有 prefix[i-1] 的最大值 |
| `s ≤ pre_mx`      | 存在和 ≤ 0 的子数组       |



是不是一般最大值的初始化是0, 最小值的初始化是无穷大?

不完全是，要看具体情况。

------

## 常见的初始化规则

| 场景     | 初始化值         | 原因           |
| -------- | ---------------- | -------------- |
| 求最大值 | `-inf`（负无穷） | 任何数都比它大 |
| 求最小值 | `inf`（正无穷）  | 任何数都比它小 |

```python
# 求最大值
max_val = float('-inf')
for x in nums:
    max_val = max(max_val, x)

# 求最小值
min_val = float('inf')
for x in nums:
    min_val = min(min_val, x)
```

------

## 那这道题为什么 pre_mx = 0？

因为这道题有特殊含义：

```python
pre_mx = 0  # 初始时，前缀和为「空」，空的和是 0
```

这里的 0 不是「最大值初始化」，而是**空前缀的和**。

```
区间:  [l+1, ..., i-1, i, ..., r]
        ←—prefix[i-1]—→

当 i = l+1 时，prefix[i-1] 是空的
空区间的和 = 0
```

------

## 对比两种情况

| 场景             | 初始值 | 原因                   |
| ---------------- | ------ | ---------------------- |
| 纯粹求数组最大值 | `-inf` | 确保第一个元素能更新它 |
| 这道题的 pre_mx  | `0`    | 空前缀的和是 0         |

------

## 举个例子区分

**场景 1：求数组最大值**

```python
nums = [-5, -3, -1]
max_val = float('-inf')  # 必须用负无穷
for x in nums:
    max_val = max(max_val, x)
# 结果: -1 ✓

# 如果用 0 初始化
max_val = 0
for x in nums:
    max_val = max(max_val, x)
# 结果: 0 ✗（错了！数组里根本没有 0）
```

**场景 2：这道题**

```python
pre_mx = 0  # 正确，因为空前缀和就是 0
```

------

## 总结

| 情况         | 最大值初始化                 | 最小值初始化 |
| ------------ | ---------------------------- | ------------ |
| 一般情况     | `-inf`                       | `inf`        |
| 有特殊含义时 | 根据题意（如空集合的和是 0） | 根据题意     |

关键是理解初始值的**实际含义**，而不是死记硬背。