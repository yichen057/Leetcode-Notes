# 题226: Invert Binary Tree

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:# 1)确定递归函数的参数和返回值: 参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为TreeNode。
        # 方法一: 层序法
        # if not root:
        #     return root
        # queue = collections.deque([root])
        # while queue:
        #     cur = queue.popleft()
        #     cur.left, cur.right = cur.right, cur.left # 交换root的两个子节点
        #     if cur.left:
        #         queue.append(cur.left)
        #     if cur.right:
        #         queue.append(cur.right)
        # return root
        # 方法二: 递归法(本题适合用前序或后序遍历, 不适合用中序, 因为中序在处理时会写成左中左, 而不是左中右, 比较麻烦)
        # 此处用前序法(中左右)
        # 2) 递归终止条件: 碰到空节点停止遍历
        if not root:
            return root
        # 3) 确定单层递归的逻辑
        root.left, root.right = root.right, root.left # 中
        self.invertTree(root.left) # 左
        self.invertTree(root.right) # 右
        return root
```

Q: 给我讲解这道题的层序遍历, 为啥不用for循环遍历每层, queue加左右子节点, 然后左子节点又变成cur这样吗

针对[226. 翻转二叉树](https://www.google.com/search?q=https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html%23%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%81%E5%8E%86)的层序遍历，我来为你拨开云雾。

其实，这道题的层序遍历**完全可以使用 `for` 循环遍历每一层**，原文的代码示例中也确实使用了 `for (int i = 0; i < size; i++)`。

------

### 1. 为什么层序遍历能翻转二叉树？

翻转二叉树的核心逻辑是：**“把每一个节点的左右孩子交换一下”**。

层序遍历（广度优先搜索）本质上是按照“从上到下、从左到右”的顺序访问每一个节点。只要我们访问到一个节点，就立刻交换它的左右子节点，当所有节点都访问并处理完毕后，整棵树就自然翻转了。

### 2. 回答你的困惑：为什么不用 `for` 循环？

实际上，**可以用，也可以不用**，这取决于你对“层序遍历”的精细度要求：

- **使用 `for` 循环（如原文 Java/Go 版本）：** 这种写法能明确区分“当前是哪一层”。在处理需要层级信息的题目（如：求每一层的平均值）时必须这么写。

- **不使用 `for` 循环（简化版 BFS）：** 只要队列不为空，就不断弹出节点进行交换。

  Python

  ```
  while queue:
      node = queue.popleft()
      node.left, node.right = node.right, node.left # 交换逻辑
      if node.left: queue.append(node.left)
      if node.right: queue.append(node.right)
  ```

  对于“翻转”操作，我们只需要处理每个节点，**并不关心它属于哪一层**。所以，不用 `for` 循环的写法更简洁。

### 3. “左子节点又变成 `cur`” 是什么意思？

你提到的“左子节点又变成 `cur`”，可能是混淆了**递归**和**层序遍历（迭代）**的逻辑：

- **层序遍历的逻辑：**
  1. 从队列取出当前节点 `cur`。
  2. 交换 `cur.left` 和 `cur.right`。
  3. 把**交换后**的 `cur.left` 和 `cur.right` 放入队列末尾。
  4. 队列会自动控制顺序，下一轮处理的是之前排好队的节点，而不是立即跳入子节点。

------

### 层序遍历执行过程示意

假设有一棵树：`[4, 2, 7]`（4是根，2是左，7是右）

1. **初始：** 队列 `[4]`。
2. **第一轮：**
   - 弹出 `4`。
   - **交换：** `4` 的左边变成 `7`，右边变成 `2`。
   - **入队：** 把新的左孩子 `7` 和右孩子 `2` 加入队列。此时队列为 `[7, 2]`。
3. **第二轮：**
   - 弹出 `7`，交换 `7` 的左右孩子（如果有的话），并将孩子入队。
4. **第三轮：**
   - 弹出 `2`，交换 `2` 的左右孩子，并将孩子入队。
5. **结束：** 队列为空，翻转完成。

------

### 总结

这道题的本质是**遍历 + 交换**。

- **前序遍历：** 先交换父节点的左右，再处理子节点。
- **后序遍历：** 先处理子节点，最后交换父节点的左右。
- **层序遍历：** 一层一层地把见到的节点左右孩子全换了。

如果你对代码中某个具体的语言版本（如 Python 或 C++）有疑问，或者想看带 `for` 循环和不带 `for` 循环的具体代码对比，我可以为你详细列出。你想看看哪种语言的实现？



# 题101: 对称二叉树 Symmetric Tree

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.compare(root.left, root.right)
    # 本题采用后续递归法,即左右中, 这里的中与普通的单树遍历有所不同
#     在标准的后序遍历中，顺序是：左子树处理 -> 右子树处理 -> 中间节点处理。
# 对于这道题，我们要判断的是以两个节点（左节点 `left` 和右节点 `right`）为根的子树是否对称：
# - **左：** 先递归比较“外侧”是否对称（`left->left` 和 `right->right`）。
# - **右：** 再递归比较“内侧”是否对称（`left->right` 和 `right->left`）。
# - **中：** 最后根据外侧和内侧的比较结果，**得出当前这两个节点的整体对称结论**并向上层返回。
    # 递归条件1: 确定递归函数的参数和返回值
    def compare(self, left, right):
    # 递归条件2: 确定递归终止条件: 节点为空, 分左右子节点
    # 条件1: 左为空, 右不空, false
    # 条件2: 左不空, 右空, false
    # 条件3: 左空, 右空, true
    # 条件4: 左不空, 右不空, 且值不相等, false
    # 条件5: 左不空, 右不空, 且值相等, 向下递归遍历, 看子孩子是否相等
        if left is None and right: return False
        if left and right is None: return False
        if left is None and right is None: return True
        if left and right and left.val != right.val: return False
    # 此时就是左右节点都不为空, 且数值相同的情况, 此时再做递归, 做下一层的判断
    # 递归条件3: 处理递归单层里的逻辑--比较内外侧节点值
        outside = self.compare(left.left, right.right) #左子树：左、 右子树：右
        inside = self.compare(left.right, right.left)  #左子树：右、 右子树：左
        result = outside and inside #左子树：中、 右子树：中 （逻辑处理）
        return result
# 在 Python 中，以下情况都会被 `if not` 判定为 `True`：

# - `None`
# - `False`
# - 数字 `0`
# - 空字符串 `""`
# - 空列表 `[]`、空字典 `{}` 等
# ### 在二叉树题目中，为什么大家常用 `if not left`？

# 在算法题（如 LeetCode）中，二叉树的节点通常是一个对象 `TreeNode`。
# - 如果节点存在，它是一个对象，布尔值为 `True`。
# - 如果节点不存在，它是 `None`，布尔值为 `False`。
# **结论：** 因为二叉树节点不会变成数字 `0` 或空字符串，所以 `if not left` 等价于检查它是不是 `None`。**这种写法更简洁，符合 Python 之禅（Pythonic）。**
        
# @lc code=end
```

Q: 本题在后序遍历时, 中如何理解呢, 我理解左为true 且右为true, 但是这个为啥就是中呢?

在 [101. 对称二叉树](https://programmercarl.com/0101.对称二叉树.html) 的递归解法中，关于**“中”**（即中间节点或根逻辑）的理解确实与普通的单树遍历有所不同。

在处理二叉树递归时，所谓的“左、右、中”顺序通常指的是**单层递归逻辑的执行位置**：

### 1. 为什么它是“后序遍历”？

在标准的后序遍历中，顺序是：**左子树处理 -> 右子树处理 -> 中间节点处理**。

对于这道题，我们要判断的是以两个节点（左节点 `left` 和右节点 `right`）为根的子树是否对称：

- **左：** 先递归比较“外侧”是否对称（`left->left` 和 `right->right`）。
- **右：** 再递归比较“内侧”是否对称（`left->right` 和 `right->left`）。
- **中：** 最后根据外侧和内侧的比较结果，**得出当前这两个节点的整体对称结论**并向上层返回。

### 2. “中”如何理解？

你理解的“左为 true 且右为 true”这部分**正是“中”逻辑的体现**。

在这个场景下，“中”不再是打印节点值或交换节点，而是一个**逻辑处理环节**：

- **逻辑内容：** 执行 `bool isSame = outside && inside;`。
- **逻辑含义：** 只有当左子树递归返回了“外侧对称”，且右子树递归返回了“内侧对称”时，我们才认定**当前这两个节点及其下的整块结构**是对称的。
- **执行时机：** 它是必须在“左”和“右”都执行完拿到结果后，才能进行的最后一步操作。因为它是放在递归函数末尾的逻辑判断，所以被归类为“后序遍历”的思想。

------

### 总结

你可以这样形象化地理解：

> “左”和“右”是在向下**探路**，“中”是在拿到探路报告后做出的**最终决策**。

因为我们需要收集完左右子树的信息（报告）后，才能在当前节点（中）得出结论，这种**“自底向上”**的信息传递方式就是典型的后序遍历逻辑。



Q: if not left和if left == None, 是一个意思吗

简单来说：在处理二叉树题目时，**它们的效果几乎是一样的，但底层的判断逻辑有细微区别。**

### 1. 核心区别

- **`if left is None` (或 `== None`)**：

  这是**精准打击**。它只检查 `left` 是不是真的是那个空空如也的 `None`。

- **`if not left`**：

  这是**广泛打击**。它会检查 `left` 的“布尔真值”（Truthiness）。在 Python 中，以下情况都会被 `if not` 判定为 `True`：

  - `None`
  - `False`
  - 数字 `0`
  - 空字符串 `""`
  - 空列表 `[]`、空字典 `{}` 等

------

### 2. 在二叉树题目中，为什么大家常用 `if not left`？

在算法题（如 LeetCode）中，二叉树的节点通常是一个对象 `TreeNode`。

- 如果节点存在，它是一个对象，布尔值为 `True`。
- 如果节点不存在，它是 `None`，布尔值为 `False`。

**结论：** 因为二叉树节点不会变成数字 `0` 或空字符串，所以 `if not left` 等价于检查它是不是 `None`。**这种写法更简洁，符合 Python 之禅（Pythonic）。**

------

### 3. 注意一个小陷阱：`is None` vs `== None`

虽然你问的是 `== None`，但在 Python 规范（PEP 8）中，更推荐使用 **`is None`**。

| **写法**           | **推荐程度** | **说明**                                             |
| ------------------ | ------------ | ---------------------------------------------------- |
| `if not left:`     | **极力推荐** | 代码最简洁，LeetCode 题解主流写法。                  |
| `if left is None:` | **推荐**     | 最安全、最严谨，明确只判断 `None`。                  |
| `if left == None:` | **不推荐**   | 效率比 `is` 略低，且可能被对象的 `__eq__` 方法干扰。 |

------

### 4. 总结对比

如果你在写**层序遍历**或**对称二叉树**：

Python

```
# 推荐写法（简洁）
if not root: 
    return []

# 严谨写法（防止 root 的值可能是 0 的情况，虽然二叉树里少见）
if root is None:
    return []
```

**一句话建议：** 在做算法题时，放心大胆地用 `if not left`，它既专业又省字符。

想看看在具体的递归代码（比如刚才说的对称二叉树）里，这两种写法混用会有什么后果吗？



# 题100: Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None and q: return False
        if p and q is None: return False
        if p is None and q is None: return True
        if p and q and p.val != q.val: return False
        left = self.isSameTree(p.left, q.left)
        right = self.isSameTree(p.right, q.right)
        result = left and right
        return result
# @lc code=end
```



# 题572: Subtree of Another Tree

```python
from typing import *
from common.node import *

# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # 只要 root 没了，就必须 return，不能让它往下走
        # 下面两句等价于:
        # if root is None:
        #   if subRoot is None:
        #     return True
        # else:
        #     return False
        #或者等价于:
        # if root is None and subRoot is None:
        #     return True
        # if root is None: # 走到这里说明 subRoot 肯定不是 None
        #     return False
        if root is None:
            return subRoot is None 
        # 此时root不为空. 先判断自己: 以当前root作为起点的二叉树, 是否和subRoot相同
        if self.isSameTree(root, subRoot):
            return True
        # 如果自己不是, 就去左子树里找有没有符合要求的, 还没找到就去右子树里找
        # root.left 不是完全等于 subRoot，但 root.left 的某个更深节点处有一棵子树等于 subRoot。
        # isSameTree(root.left, subRoot) 会直接返回 False，而 isSubtree(root.left, subRoot) 会继续往下找。
        # 所以这里必须递归调用 isSubtree，而不是 isSameTree。
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
    
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool: # 可以简写为: def isSameTree(self, p: TreeNode, q: TreeNode)
        if p is None and q is None:# 这里判断了 p 和 q 同时为空的情况 # 这里如果同一个节点被共享, 那么q is q, 所以这句也可以写成if p is q: # 同一个对象（包含两个都是 None）
            return True
        if p is None or q is None: # 这里判断了 p 和 q 其中一个为空的情况: p为空, q不空;p不空, q为空
            return False
        # 此时p and q 是不为空的
        if p.val != q.val:
            return False
        # 此时p and q不为空且值相等,向下遍历判断左子和右子节点是否相同
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        

# @lc code=end
```



针对 [LeetCode 572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)，这道题的核心思路是：**“双重递归”**。

简单来说，我们要在大树 `root` 中，不断地寻找是否存在一个“支点”，使得从这个点开始的整棵子树，和 `subRoot` 完全一模一样。

------

### 1. 代码逻辑拆解

这段代码由两个函数组成，分工非常明确：

#### 第一层递归：`isSubtree` (寻找起点)

它的任务是：**在大树中“遍历”每一个节点。**

- **判断自己：** 看看以当前的 `root` 作为起点，是不是和 `subRoot` 是一样的？（调用 `isSameTree`）。
- **判断左边：** 如果自己不是，那就去左子树里找找看有没有符合要求的。
- **判断右边：** 还没找到？那就去右子树里找。
- **逻辑：** 只要“自己、左子树、右子树”三者中有一个返回 `True`，结果就是 `True`。

#### 第二层递归：`isSameTree` (严格对比)

它的任务是：**给定两个起点，判断这两棵树是否“克隆”关系。**

- **终止条件：** 两个都为空（相同，返回 `True`）；一个空一个不空（不相同，返回 `False`）。
- **值对比：** 当前两个节点的值如果不等，直接判死刑（返回 `False`）。
- **递归对比：** 必须满足“我的左边和你的左边一样” **且** “我的右边和你的右边一样”。

------

### 2. 深度理解逻辑

你可以把这个过程想象成**“找模板”**：

1. `isSubtree` 就像是在整幅画（`root`）中移动一个放大镜，每到一个新位置，它就问一声：“这里像不像我们要找的小图（`subRoot`）？”
2. `isSameTree` 就像是那个仔细的核对员。当 `isSubtree` 喊它时，它就开始从当前位置出发，一个像素一个像素（节点）地对比，直到确定完全一致或者发现不同。

------

### 3. 回答你之前的疑惑点

- **关于 `is None`：** 代码中大量使用了 `if p is None`，这比 `if not p` 更严谨。例如在 `isSubtree` 开头，如果大树找空了（`root is None`），而小树还没找着，那肯定就不存在子树了。
- **关于后序/前序思想：**
  - `isSameTree` 的逻辑是：**值相等 + 左边相等 + 右边相等**。由于必须先比较当前值，所以它带有**前序遍历**的影子。
  - `isSubtree` 的返回逻辑：`return 自己相同 or 左边有相同 or 右边有相同`。这是一种**自顶向下**的搜索过程。

### 4. 复杂度分析

- **时间复杂度：** $O(M * N)$。其中 M 是大树节点数，N 是小树节点数。最坏情况下，对大树的每个节点都要进行一次全量对比。
- **空间复杂度：** $O(max(H_{root}, H_{sub}))$。主要是递归调用的栈空间，取决于树的高度。

**你会发现这道题其实是“相同的树”那道题的进阶版。想让我帮你分析一下，如果不使用这种双重递归，有没有更高效（比如 $O(M+N)$）的解法吗？**



Q: class Solution:

​    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:

​        if root is None:

​            return subRoot is None

​        这几句没看懂return的意思



这三行代码是整个递归的**基准出口（Boundary Condition）**，非常关键。为了让你直观理解，我们把它拆开来看：

Python

```
if root is None:
    return subRoot is None
```

这段代码等同于：**“如果大树（root）已经找完了，那结果取决于小树（subRoot）是不是也是空的。”**

### 1. 拆解逻辑（翻译成人话）

我们可以把这行 `return` 分解为两种情况：

- **情况 A：大树找空了，小树也是空的**
  - `root` 是 `None`，`subRoot` 也是 `None`。
  - `subRoot is None` 的结果是 **`True`**。
  - 这符合逻辑：空树当然是空树的子树。
- **情况 B：大树找空了，但小树还有节点**
  - `root` 是 `None`，但 `subRoot` 并不是 `None`。
  - `subRoot is None` 的结果是 **`False`**。
  - 这符合逻辑：如果你在空林子里找一棵存在的树，那肯定找不着，返回 `False`。

------

### 2. 为什么 `isSubtree` 需要这个判断？

在 `isSubtree` 的递归逻辑中，我们会不断调用：

```
self.isSubtree(root.left, subRoot)
```

当你一直往左下方找，直到超越了叶子节点，此时 `root` 就变成了 `None`。

- 这时候如果你还没在上面找到匹配的子树，而现在大树已经“到头了”，说明这条路断了。
- **注意：** 因为题目要求 `subRoot` 至少有一个节点（通常 LeetCode 给的范围是 $n \ge 1$），所以在大树为空时，基本都会返回 `False`。

------

### 3. 对比：`isSubtree` vs `isSameTree`

你可能会混淆这两个函数里的 `None` 判断，它们是有微妙区别的：

| **函数**         | **判断逻辑**                          | **为什么这样写？**                   |
| ---------------- | ------------------------------------- | ------------------------------------ |
| **`isSameTree`** | `if not p and not q: return True`     | 两个都走到头了，说明**完全一致**。   |
| **`isSubtree`**  | `if not root: return subRoot is None` | 大树走到头了，说明**没地方再找了**。 |

### 4. 形象化理解

想象你在翻一本厚书（`root`），想找一个特定的段落（`subRoot`）：

- `if root is None` 表示：**书翻到最后一页了，还没找着。**
- `return subRoot is None` 表示：**除非你原本要找的就是“空白页”，否则就是没找着（False）。**

------

**一句话总结：**

这行代码的作用是给递归垫底，防止程序在 `root` 变成 `None` 之后还去调用 `root.left` 导致报错，同时也给出了“没找着”的最终信号。

**这个“逻辑返回值”的写法在 Python 里非常常见，如果不习惯这种简写，你也可以写成：**

Python

```
if root is None:
    if subRoot is None:
        return True
    else:
        return False
```

这两种写法是完全等价的。你觉得哪种写法的思路对你来说更顺畅？



Q:  if root is None and subRoot is None: return True

​        else: return False

那这个和if root is None:

​    if subRoot is None:

​        return True

​    else:

​        return False

是不是不一样



你观察得非常仔细！这两个写法在**逻辑结果**上是一样的，但它们在**程序执行的流程**（或者说判断的边界）上有一点细微的区别。

简单来说：

- **写法 A (`if root is None and subRoot is None`)**：只有当两者**同时为空**时才返回 `True`，否则进入后续逻辑。
- **写法 B (`if root is None: if subRoot is None...`)**：只要 **`root` 为空**，就必须在这里做一个“了断”，直接返回结果（要么 `True` 要么 `False`），不再往下运行。

------

### 1. 为什么写法 B（原代码）更适合这道题？

在 `isSubtree` 这个函数里，写法 B 的逻辑是：

> “只要大树（`root`）找完了，这次搜索就结束了。”

如果我们用你的 **写法 A**：

Python

```
if root is None and subRoot is None: 
    return True
# 如果 root 是 None，但 subRoot 不是 None，程序会跳过这里，继续往下走
if self.isSameTree(root, subRoot): # 报错！因为 root 是 None，不能传进 isSameTree
    ...
```

**致命点：** 如果 `root` 是 `None` 而 `subRoot` 不是 `None`，写法 A 会让程序继续运行到后面的 `isSameTree(root, subRoot)`。因为 `root` 是空的，这时候代码就会**报错（AttributeError）**。

### 2. 逻辑对比图

为了清晰，我们对比一下这两种逻辑的处理方式：

| **情况**                  | **写法 A (and 判断)**                     | **写法 B (嵌套判断 / 原代码)**         |
| ------------------------- | ----------------------------------------- | -------------------------------------- |
| **两者都为空**            | 返回 `True` (正确)                        | 返回 `True` (正确)                     |
| **root为空, subRoot不空** | **跳过 if，继续执行后面代码 -> 导致报错** | **进入 if，返回 `False` (正确地终止)** |
| **root不空**              | 跳过 if，继续执行 (正确)                  | 跳过 if，继续执行 (正确)               |

------

### 3. 如何修正写法 A？

如果你想用 `and` 这种简洁的写法，同时还要保证程序不报错，你需要写成这样：

Python

```python
if root is None:
    return subRoot is None # 只要 root 没了，就必须 return，不能让它往下走
```

或者更直白的写法（虽然啰嗦一点）：

Python

```python
if root is None and subRoot is None:
    return True
if root is None: # 走到这里说明 subRoot 肯定不是 None
    return False
```

### 总结

你写的写法 A 漏掉了一种情况的处理：**“当 `root` 已经为空，但 `subRoot` 还没空”** 时该怎么办。

原代码之所以写 `if root is None:`，其实是把它当成了一个**“截断信号”**：只要大树翻到了尽头，不管结果如何，当前这层递归都必须结束并返回一个布尔值，绝对不能让 `None` 进入到后面的 `isSameTree` 或者 `root.left` 逻辑中。

**这就是为什么在递归中，我们通常先写“死路一条”的边界条件判断。明白为什么写法 A 会导致后面代码“撞墙”了吗？**



Q:def isSameTree(self, p: TreeNode, q: TreeNode)

为什么这里不用判断是否为空呢



这是一个非常敏锐的观察。实际上，在 `isSameTree` 的函数体内部，**是有判断是否为空的**，只是它没有放在函数的最开始，而是作为逻辑的一部分。

我们来看一下代码的前两行：

Python

```python
def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
    # 1. 判断一对节点是否相同
    if p is None and q is None: # 这里判断了 p 和 q 同时为空的情况
        return True
    if p is None or q is None:  # 这里判断了 p 和 q 其中一个为空的情况
        return False
    # ... 后面才会执行 p.val
```

### 1. 为什么不在进入函数前判断？

你可能会想：在调用 `self.isSameTree(p.left, q.left)` 之前，为什么不先判断 `p.left` 是不是 `None`？

这是递归的一种**常用技巧**，叫做**“空节点也看作一棵树”**：

- **做法 A（把判断写在函数内）：** 不管子节点是不是 `None`，统统传进 `isSameTree`。让函数在下一层的第一行代码去处理 `None`。这样主逻辑很整洁。
- **做法 B（把判断写在调用前）：** 在调 `isSameTree` 前先写一堆 `if p.left is not None`。这样会使代码变得非常臃肿，且容易漏掉某种组合情况。

------

### 2. 这里的判断逻辑非常精妙

这两行 `if` 其实涵盖了**所有**涉及 `None` 的可能性，起到了“全自动守卫”的作用：

- **情况 1：`p` 为空，`q` 为空**
  - 触发 `if p is None and q is None` $\rightarrow$ 返回 `True`。
  - **意义：** 两个空位置是对称/相同的。
- **情况 2：`p` 为空，`q` 不为空**
  - 不满足第一个 `if`，但满足 `if p is None or q is None` $\rightarrow$ 返回 `False`。
  - **意义：** 结构不对称。
- **情况 3：`p` 不为空，`q` 为空**
  - 同上，满足 `or` 条件 $\rightarrow$ 返回 `False`。
- **情况 4：`p` 不为空，`q` 不为空**
  - 两个 `if` 都不满足。这时候程序才会运行到 `if p.val != q.val`。
  - **关键：** 因为有了前面的过滤，运行到 `p.val` 时，**编译器和解释器百分之百确定 `p` 和 `q` 都不是 `None`**，所以绝对不会报空指针异常。

------

### 3. 总结

所以，不是“不用判断”，而是**“把判断转化成了递归的终止条件”**。

这种写法在二叉树题目中是**标准模板**：

1. **先判空**（终止条件）。
2. **再判值**（当前层逻辑）。
3. **再递归**（处理子树）。

### 形象化理解

这就好比两个质检员在检查两排盒子：

- 如果两个位子都没盒子了，他们汇报“一样（都是空）”。
- 如果一个位子有盒子，另一个没有，他们汇报“不一样”。
- 如果都有盒子，他们才拆开盒子比里面的东西。

**如果你把判空逻辑放在调用前，就像是在拆盒子之前还要先疯狂摸地板确认有没有盒子，代码就会写得非常乱。你觉得这种“先传进去，再在函数头处理”的思路好理解吗？**



Q: 代码逻辑本身是对的，但 isSameTree 可以提前用 if p is q 做快速路径（不改也没问题）。 展开说说

“if p is q 做快速路径”的意思是：在 isSameTree 一开始先判断两个引用是不是同一个对象。如果是同一个对象，肯定表示同一棵树（或同一个空节点），可以直接返回 True，不用继续递归。

比如：

```
def isSameTree(p, q):    if p is q:      # 同一个对象（包含两个都是 None）        return True    if p is None or q is None:        return False    if p.val != q.val:        return False    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right) 
```

展开说几点价值：

- **包含 None 的情况**：如果 p 和 q 都是 None，p is q 为 True，直接返回，省掉后面的判断。
- **性能小优化**：当递归过程中有某些子树引用刚好相同（比如同一个节点被共享，或者调用时两参数就是同一个对象），能直接返回，不用继续遍历。
- **逻辑更清晰**：先处理“完全同一个对象”这个最强条件，能让后面的逻辑更干净。

但它是“微优化”，在 LeetCode 的普通树结构里通常不会共享节点，所以是否加都无所谓。适合你想写得更严谨、稍微更高效时加上。



Q: 还有个问题, 为啥# @lc code=start # Definition for a binary tree node. # class TreeNode: #     def __init__(self, val=0, left=None, right=None): #         self.val = val #         self.left = left #         self.right = right 这些都打了批注了, 还是可以调用.val, .left和.right呢?

这些是 LeetCode 模板的注释，占位说明而已。真正运行时，平台已经在后台**提供了 TreeNode 类的定义**并创建好了树节点对象，所以你依然可以访问 [node.val](https://file+.vscode-resource.vscode-cdn.net/Users/yichen/.vscode/extensions/openai.chatgpt-0.4.68-darwin-arm64/webview/#)、[node.left](https://file+.vscode-resource.vscode-cdn.net/Users/yichen/.vscode/extensions/openai.chatgpt-0.4.68-darwin-arm64/webview/#)、node.right。

本地运行时你是通过 from common.node import * 引入了 TreeNode，所以同样能访问这些字段。

简单说：

- 注释里的 TreeNode 只是说明“这个类长这样”。
- 实际类定义由平台/你自己的导入提供。
- 只要运行环境里有真正的 TreeNode 类，就能访问 .val/.left/.right。



Q: return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot) 为啥左子树和右子树不能直接调用isSameTree()函数呢?

因为 isSameTree 是“**从当前节点开始整棵树是否完全相同**”，它不会去“遍历并寻找子树”。

我们在 isSubtree 里要做的是：

- 先判断“**当前 root 这棵树**是不是和 subRoot 一样”（用 isSameTree）
- 如果不是，就继续去 root 的左子树里 **找有没有** 某个位置能匹配 subRoot
- 再去右子树里找

如果你在递归时直接用：

```
return self.isSameTree(root.left, subRoot) or self.isSameTree(root.right, subRoot) 
```

那就只检查 “root.left 整棵树是否等于 subRoot” 和 “root.right 整棵树是否等于 subRoot”，
**不会继续深入**左子树/右子树内部去找子树，所以会漏掉很多情况。

举个例子：
root.left 不是完全等于 subRoot，但 root.left 的某个更深节点处有一棵子树等于 subRoot。
isSameTree(root.left, subRoot) 会直接返回 False，而 isSubtree(root.left, subRoot) 会继续往下找。

所以这里必须递归调用 isSubtree，而不是 isSameTree。