class Solution:
    """
        题目要求：所有长度 ≥ 3 的子数组的和都必须是正数
        操作：可以把任意元素改成任意值
        目标：最少需要多少次操作
        
        核心思路：
        - 从左到右遍历，维护一个「安全区间」[l+1, r]
        - 检查以 r 结尾、长度 ≥ 3 的子数组是否有和 ≤ 0 的
        - 如果有，就在位置 r 做修改，然后重新开始
        """
    
    def makeArrayPositive(self, nums: List[int]) -> int:
        # 当前安全区间设为是 [l+1, r], 子数组区间为[i, r]
        l = -1  # 上一次修改的位置（初始为 -1，表示还没修改过）
        s = 0 # 当前区间 [l+1, r] 的总和: 现在 s = sum[l+1, r]
        pre_max = 0 # 区间 [l+1, r-2] 内所有前缀和的最大值: max(所有的prefix[i-1]), pre_max需记录到从l+1到r-2的前缀和最大值, 也就是总和s-nums[r]-nums[r-1]的最大值
                    # pre_max=0, 初始为 0，因为空前缀的和是 0
                    # 用途：快速判断是否存在和 ≤ 0 的子数组
        ans = 0 # 记录操作次数

        for r, x in enumerate(nums): # x = nums[r]，当前遍历到的元素
            s += x # 更新区间和，现在 s = sum[l+1, r]
        # 需判断以r结尾, 长度>=3的子数组, 子数组的和<=0--> 满足条件即operate once: ans + 1   
            # ============ 条件1：检查是否需要修改 ============
            # 条件1: i作为子数组的起点, 子数组[i, r]的区间长度>=3 -->只有起点i在[l+1, r-2]这个范围内的子数组才需要检查:r-(l+1)+1>2-->r-l>2;    r-i+1>=3 --> i <= r-2 且 i>= l+1; 
            # 子数组[i, r]的和 <= 0 --> s总和-prefix[i-1]前面那部分和<=0 --> 即s <= prefix[i-1] ---> s <= pre_max
            if r - l > 2 and s <= pre_max:
                ans += 1  #满足条件, 需要修改一个元素
                l = r #在位置r做修改, 重新开始新区间[l+1, r]
                pre_max = s = 0 # 重置状态（新区间从 l+1 开始算）

            # ============ 条件2：更新 pre_mx ============
            # r - l >= 2：区间长度 >= 2 时才需要更新
            # 注意：这个 elif 保证了条件1不满足时才执行, ans不加1
            elif r-l >= 2:
                pre_max = max(pre_max, s - x - nums[r - 1])
                # s - x - nums[r-1] 是什么？
                # s              = sum[l+1, r]     整个区间的和
                # s - x          = sum[l+1, r-1]   去掉最后一个元素
                # s - x - nums[r-1] = sum[l+1, r-2] 去掉最后两个元素
                # 
                # 这就是「到位置 r-2 的前缀和」
                # 因为子数组 [i, r] 长度 ≥ 3 要求 i ≤ r-2
                # 所以 pre_mx 只记录到 r-2 的前缀和
        
        return ans