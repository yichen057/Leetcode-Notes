# 题110:  Balanced Binary Tree

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 平衡二叉树: 二叉树里任何一个节点, 它的左右子树的高度差不能超过1, 即<=1
# 高度: 任意一个节点和叶子节点的距离. 求高度要用后序遍历做(左右中). 叶子节点: 左右孩子都为空
# 深度: 任意一个节点和根节点的距离, 求深度要用前序遍历做(中左右)
# 
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if self.getHeight(root) != -1:
            return True
        else:
            return False
    # 后序递归遍历法求高度
    def getHeight(self, root: Optional[TreeNode]) -> int: # 1) 递归函数的返回类型为int, 参数是二叉树的根节点
        # 2) 递归的终止条件 Base Case
        if not root:
            return 0
        # 3) 单层递归处理逻辑: 后序遍历(左右中)
        # 左
        leftHeight = self.getHeight(root.left) # Note: python里调用函数要加self.
        if leftHeight == -1:
            return -1
        # 右
        rightHeight = self.getHeight(root.right)
        if rightHeight == -1:
            return -1
        # 中: 此时左右子树都符合平衡二叉树的条件, 就比较高度差即可
        if abs(rightHeight - leftHeight) >1:
            return -1
        else: #此时高度差也符合条件: 即左右子树的高度差<=1, 那么当前父节点的高度 = 1+左右子树高度的最大值, +1表示父节点本身的高度
            return 1 + max(rightHeight, leftHeight)
# 以下为递归法精简版:
class Solution:
    def isBalanced(self, root:Optional[TreeNode]) -> bool:
        return self.getHeight(root) != -1
    def getHeight(self, node):
        if not node:
            return 0
        leftHeight = self.getHeight(node.left)
        rightHeight = self.getHeight(node.right)
        if leftHeight == -1 or rightHeight == -1 or abs(rightHeight - leftHeight) > 1:
            return -1
        else:
            return 1+ max(leftHeight, rightHeight)
# @lc code=end
```

Q: leetcode里的root: Optional[TreeNode]和root: TreeNode有区别吗?

在 LeetCode 以及 Python 类型提示（Type Hints）中，`root: Optional[TreeNode]` 和 `root: TreeNode` 的主要区别在于是否允许**空值（None）**。

虽然在很多情况下 LeetCode 的后台运行并不强制要求类型完全匹配，但从编程规范和静态类型检查的角度来看，区别如下：

### 1. `root: Optional[TreeNode]` (更推荐、更严谨)

这是二叉树题目中最准确的写法。

- **含义**：`Optional[TreeNode]` 等同于 `Union[TreeNode, None]`。它明确告诉阅读者和 IDE：这个变量既可以是 `TreeNode` 实例，也可以是 `None`。
- **适用场景**：二叉树的根节点完全可能是空的（即空树）。在你的代码截图里，`if not node: return 0` 就是为了处理 `None` 的情况。
- **Python 3.10+ 写法**：在新版 Python 中，通常简写为 `root: TreeNode | None`。

### 2. `root: TreeNode` (不够严谨)

这种写法在技术上表示参数**必须**是一个 `TreeNode` 对象。

- **含义**：它声明该函数不接受 `None`。
- **潜在问题**：如果你的代码里没有处理 `if not root`，而传入的是空树，类型检查工具（如 MyPy）会报错，程序在运行时也可能抛出 `AttributeError: 'NoneType' object has no attribute 'left'`。
- **LeetCode 现状**：虽然 LeetCode 自动生成的模板有时会省略 `Optional`，但在实际逻辑中，树的根节点几乎总是需要考虑为空的情况。

------

### 总结对比

| **特性**            | **Optional[TreeNode]**              | **TreeNode**               |
| ------------------- | ----------------------------------- | -------------------------- |
| **是否允许 `None`** | **允许**                            | **理论上不允许**           |
| **严谨程度**        | 高（符合二叉树可能为空的实际）      | 低（忽略了空树的情况）     |
| **代码安全性**      | 提醒开发者必须做 `if not root` 检查 | 可能诱导开发者漏掉判空逻辑 |

**结论：**

在编写二叉树相关算法时，你应该习惯性地将其视为 **`Optional`**。正如你截图中的“递归法精简版”代码所示，使用了 `root: Optional[TreeNode]` 是一种更专业的编程习惯。

你想了解一下在 Python 中如何利用这些类型提示来获得更好的代码补全建议吗？

Q: python里取绝对值的方式:

在 Python 中，取绝对值非常简单，主要有以下几种方式：

### 1. 使用内置函数 `abs()`

这是**最常用**的方法，不需要导入任何模块，可以直接处理整数、浮点数。

Python

```
num1 = -10
num2 = -3.14

print(abs(num1))  # 输出: 10
print(abs(num2))  # 输出: 3.14
```

### 2. 在处理数学计算时使用 `math.fabs()`

如果你已经导入了 `math` 库，可以使用这个函数。它与 `abs()` 的主要区别是：`math.fabs()` 始终返回**浮点数 (float)**。

Python

```
import math

print(math.fabs(-10))  # 输出: 10.0
```

------

### 结合本题场景 (110. 平衡二叉树)

在[平衡二叉树](https://programmercarl.com/0110.平衡二叉树.html)的题目逻辑中，我们需要判断左右子树的高度差是否超过 1。在 Python 代码实现中，通常会这样写：

Python

```
# 假设 left_height 和 right_height 是左右子树的高度
if abs(left_height - right_height) > 1:
    return -1  # 表示不平衡
```

正如你在页面代码中看到的，`abs()` 是判断平衡逻辑的核心工具。

**您是想在递归法中加入这个判断，还是在迭代法中计算高度差呢？**



Q: if (left_height := self.get_height(root.left)) == -1:这句如何理解

这段代码使用了 Python 3.8 引入的 **海象运算符（Walrus Operator）** `:=`。

你可以通过以下三个层面来理解这句代码：

### 1. 语法拆解

这行代码实际上完成了两件事：

1. **赋值**：调用 `self.get_height(root.left)`，并将返回的结果赋值给变量 `left_height`。
2. **判断**：立即使用这个新赋值的 `left_height` 与 `-1` 进行比较。

### 2. 等价写法

如果没有海象运算符，这段逻辑通常需要写成两行：

Python

```
left_height = self.get_height(root.left) # 先赋值
if left_height == -1:                   # 再判断
    return -1
```

### 3. 在本题逻辑中的作用

这句代码是**平衡二叉树**递归判断中的“剪枝”操作：

- **递归调用**：它正在获取左子树的高度。
- **异常标记**：在 `get_height` 函数的设计中，如果发现子树不是平衡二叉树，会返回 `-1` 作为特殊标记。
- **提前退出**：这句代码的含义是：“如果左子树已经不平衡了（返回了 -1），那么以当前节点为根的整棵树肯定也不平衡，直接向上返回 -1，不需要再计算右子树了”。

**总结：** 这种写法让代码更加简洁，在同一行内完成了获取高度、存储高度以备后用、以及结果合法性检查这三个动作。



# 题257: Binary Tree Paths二叉树的所有路径

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 递归法 + 回溯
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        result = [] # result是string字符串数组用来记录字符串结果
        path=[] # path是int整数数组用来记录单条路径的
        if not root:
            return result
        self.traversal(root,path, result)
        return result
    # 递归前序遍历: 只有这样才能自上而下让父节点指向左右子节点 (中左右)
    # 本题还引入了"回溯", 一个递归一个回溯, 一体化
    def traversal(self, cur, path, result) -> None: # cur: 根节点; 当没有返回值时写None, 而不是void
        # 中. 此处中的处理过程放base case前面, 是为了在进入左右子树递归前, append当前节点的值, 同时为了让叶子节点的值可以加入path里, 否则如果直接return了, 叶子节点都还没加入到result里
        path.append(cur.val)
        # base case: 到达叶子节点(左右孩子都为空)就结束并记录和返回路径, 没必要遍历到空节点
        if not cur.left and not cur.right:
            # 将path整数数组转为字符串数组, 并用->拼接
            sPath = '->'.join(map(str, path)) #  join 函数只能连接字符串列表, 用 `'->'.join(...)` 把这些字符串用箭头连起来; 用 map(str, path) 把路径里的数字全变字符串
            # 在 Python 里，`map(function, iterable)` 函数的作用是将指定的 `function`（函数）依次作用于 `iterable`（可迭代对象，如列表、元组）的每一个元素上。
            # str：是 Python 的内置类型转换函数，可以将数字转为字符串。
            # path：是一个整数列表，例如 [1, 2, 3]
            # map(str, path) 会把列表里的每个数字都变成字符串，得到类似 `['1', '2', '3']` 的效果。
            result.append(sPath) #注意: 这里append的可不是path, 而是从数字转换为字符串的sPath
            return
        # 左
        if cur.left:
            self.traversal(cur.left, path, result) # 递归函数内部的第一步是append当前节点
            path.pop() # 回溯, 弹出左子树的元素. 只有退出了当前的左子树pop, path才能进入右子树
        # 右
        if cur.right:
            self.traversal(cur.right, path, result) # 递归
            path.pop() # 回溯
# @lc code=end
```

- 针对 [257. 二叉树的所有路径](https://programmercarl.com/0257.二叉树的所有路径.html) 的 Python 实现，页面提供了几种核心写法。为了方便理解，我按照“逻辑由显到隐”的顺序为你讲解：

  ------

  ### 1. 递归法 + 显式回溯（最推荐入门理解）

  这是你截图里的第一种写法，也是最能体现算法本质的写法。

  - **核心逻辑**：使用一个列表 `path` 记录路径上的节点值。
  - **回溯的体现**：
    - 在进入左/右子树递归前，先 `append` 节点。
    - **关键点**：递归调用结束后，必须执行 `path.pop()`。
  - **为什么好理解**：它清晰地展示了“进去之后还要出来”的过程。只有退出了当前的左子树（pop），`path` 才能干净地进入右子树。

  ### 2. 递归法 + 隐形回溯（版本一：利用切片）

  这种写法在调用递归函数时使用了 `path[:]`（即路径的副本）。

  - **核心逻辑**：`self.traversal(cur.left, path[:], result)`。
  - **回溯的体现**：因为它传给子函数的是当前路径的一个**拷贝**，子函数对路径的任何修改都不会影响当前层的 `path`。
  - **优缺点**：代码看起来更短，不需要写 `pop()`，但本质上是通过大量复制列表来实现的，空间开销比显式回溯略大。

  ### 3. 递归法 + 隐形回溯（版本二：利用字符串加法）

  这种写法将路径直接存储为字符串。

  - **核心逻辑**：`self.traversal(cur.left, path + '->', result)`。
  - **回溯的体现**：在 Python 中，字符串是**不可变对象**。当执行 `path + '->'` 时，产生了一个全新的字符串传给下一层。
  - **为什么不用 pop**：当递归返回到父节点时，父节点的 `path` 变量依然是原来的那个字符串，没有被修改过，自然就实现了“回溯”。

  ### 4. 迭代法（使用栈模拟）

  如果你不喜欢递归，这种方法利用“双栈”来同步节点和路径。

  - **核心逻辑**：一个栈 `stack` 存节点，另一个栈 `path_st` 存到达该节点的路径字符串。
  - **理解点**：它是前序遍历的变体。每弹出一个节点，就把它的左右孩子及其对应的“新路径字符串”压入栈中。
  - **特点**：完全不需要考虑显式的回溯操作，因为路径信息是和节点直接绑定的，随入栈出栈而更新。

  ------

  ### 总结与建议

  - **最有助于深入理解**：**第一种（显式回溯）**。理解了 `path.pop()`，你就理解了所有回溯算法（如组合、排列问题）的基础。
  - **最简洁**：**第三种（字符串隐形回溯）**。利用 Python 语言特性，代码最少，不容易出错。

  如果你是刚开始学习回溯，建议先把第一种写法的 `path.pop()` 逻辑画图模拟一遍。

  **需要我针对其中某一种写法的具体某行代码再深入剖析吗？**

Q: 那在进入左右子树递归前, append的什么节点呢

根据你提供的代码截图和 [257. 二叉树的所有路径](https://programmercarl.com/0257.二叉树的所有路径.html) 的逻辑，在进入左右子树递归前，`append` 的是 **当前节点（即 `cur` 节点）的值**。

具体逻辑如下：

### 1. 哪一行在执行 append？

在 `traversal` 函数的最开始（截图中的第 4 行）：

Python

```
path.append(cur.val) # 中
```

这一行代码在处理任何子树递归之前，先将**当前正在访问的节点值**放入路径列表 `path` 中。

### 2. 执行的顺序是怎样的？

由于这是一个**前序遍历**（中->左->右）的过程，`append` 的执行时机非常关键：

1. **处理“中”**：先把当前节点 `cur` 的值加入 `path`。
2. **判断叶子**：如果是叶子节点，就记录路径并返回。
3. **递归“左”**：如果左孩子存在，调用 `self.traversal(cur.left, ...)`。此时，左孩子在它自己的递归函数里，也会第一步执行 `path.append(cur.left.val)`。
4. **回溯**：左边递归回来后，执行 `path.pop()` 把左孩子踢出去。
5. **递归“右”**：右孩子同理。

### 3. 举个例子

假设树的结构是 `1 -> 2`:

- 刚进入 `traversal(root)` 时，`cur` 是节点 1，执行 `path.append(1)`。此时 `path = [1]`。
- 发现有左孩子 2，调用 `traversal(node_2)`。
- 在 `traversal(node_2)` 的第一行，执行 `path.append(2)`。此时 `path = [1, 2]`。

**总结：**

并不是在“进入递归前”的一瞬间 append，而是在**递归函数内部的第一步** append 掉当前节点。这样可以确保路径是从根节点开始，一个接一个地把沿途经过的节点值都记录下来。

你想试试模拟一下如果有 3 个节点（根、左、右）时，这个 `path` 列表的具体变化过程吗？

对于 **[257. 二叉树的所有路径](https://programmercarl.com/0257.二叉树的所有路径.html)** 这道题，在进入左右子树递归前，`path.append(cur.val)` 是非常标准且好理解的操作。

既然你觉得这个流程可以理解，我们可以通过一个简单的**模拟过程**，帮你彻底固化这个“递归 + 回溯”的思维模型。

------

### 模拟：以树 `1 -> 2, 3` 为例

假设树的结构如下：

Plaintext

```
    1
   / \
  2   3
```

1. **进入 `traversal(节点1)`**:
   - 执行 `path.append(1)`，此时 `path = [1]`。
   - 检查不是叶子节点，进入左递归。
2. **进入 `traversal(节点2)`**:
   - 执行 `path.append(2)`，此时 `path = [1, 2]`。
   - **判定为叶子节点**：将 `"1->2"` 加入结果集 `result`。
   - 执行 `return` 回到上一层。
3. **回到 `traversal(节点1)` 的左递归之后**:
   - **关键回溯**：执行 `path.pop()`，此时 `path` 恢复为 `[1]`。
   - 这步保证了接下来去右边时，路径里不会带着左边的 `2`。
4. **进入 `traversal(节点3)`**:
   - 执行 `path.append(3)`，此时 `path = [1, 3]`。
   - **判定为叶子节点**：将 `"1->3"` 加入 `result`。
   - 执行 `return` 并后续触发 `pop()`。

------

### 为什么这个顺序最清晰？

这种写法的核心在于**对称性**：

- **处理中节点**：进来就 `append`，表示“我路过了这个点”。
- **处理子节点**：去递归左/右子树。
- **回溯处理**：递归回来立刻 `pop`，表示“我离开了这个点，要把位置腾给其他兄弟节点”。

### 注意一个细节

在截图的代码中，`path.append(cur.val)` 放在了判断叶子节点的前面。

- **好处**：保证了当到达叶子节点时，`path` 里已经包含了当前叶子节点的值，可以直接进行字符串拼接。
- **对比**：如果你先判断叶子再 `append`，那么你在记录路径时就会漏掉最后一个叶子节点的值。

**既然这个逻辑你已经掌握了，想挑战一下看看“迭代法”是如何利用两个栈（一个存节点，一个存路径字符串）来模拟这个过程的吗？**



Q: sPath = '->'.join(map(str, path)) 讲解这个语法

这行代码 `sPath = '->'.join(map(str, path))` 的作用是将路径列表 `path`（例如 `[1, 2, 3]`）转换成题目要求的字符串格式（例如 `"1->2->3"`）。

我们可以将其拆解为三个步骤来理解：

### 1. `map(str, path)`：类型转换

在 `path` 列表中，存储的是整数类型的节点值（如 `1`），而字符串拼接需要字符类型。

- **作用**：`map` 函数会将 `str`（字符串转换函数）应用到 `path` 列表中的每一个元素上。
- **结果**：将 `[1, 2, 3]` 转换为一个可以迭代的对象，内容类似于 `['1', '2', '3']`。

### 2. `'->'.join(...)`：字符串连接

这是 Python 中拼接字符串序列的常用方法。

- **语法**：`'分隔符'.join(可迭代对象)`。
- **作用**：它会将序列中的元素用指定的“分隔符”（这里是 `->`）连接起来。
- **结果**：将 `['1', '2', '3']` 变成 `"1->2->3"`。
- **优点**：它非常智能，只会在元素**之间**添加 `->`，而不会在最后一个元素后面多加一个箭头。

### 3. `sPath = ...`：变量赋值

- **作用**：将最终生成的完整字符串保存到变量 `sPath` 中，随后通过 `result.append(sPath)` 存入结果集。

------

### 举例说明

假设当前路径 `path = [1, 2, 5]`：

1. **`map(str, path)`** -> 变成 `["1", "2", "5"]`。
2. **`'->'.join(...)`** ->  用 `->` 连接它们，得到 `"1->2->5"`。

**相比于 C++ 需要用 `for` 循环手动拼接字符串并处理最后一个箭头的逻辑，Python 这一行代码利用内置函数简洁地完成了所有工作。**



Q: 这个map(str, path)不是字典结构的那种key, value吗

在 Python 中，这里的 `map(str, path)` 与字典（Dictionary）中的 `map`（映射）概念不同，它是一个**内置函数**，用于**对序列中的每一个元素执行特定的操作**。

以下是详细的讲解：

### 1. 这里的 `map` 是什么？

在 Python 里，`map(function, iterable)` 函数的作用是将指定的 `function`（函数）依次作用于 `iterable`（可迭代对象，如列表、元组）的每一个元素上。

在 `sPath = '->'.join(map(str, path))` 这行代码中：

- **`path`**：是一个整数列表，例如 `[1, 2, 3]`。
- **`str`**：是 Python 的内置类型转换函数，可以将数字转为字符串。
- **结果**：`map(str, path)` 会把列表里的每个数字都变成字符串，得到类似 `['1', '2', '3']` 的效果。

### 2. 为什么不直接用 `path`？

因为 **`join` 函数只能连接字符串列表**。

- 如果直接写 `'->'.join(path)`，由于 `path` 里是整数（int），Python 会报错。
- 使用 `map(str, path)` 将它们统一转换成字符串后，才能成功拼接成 `"1->2->3"` 这种格式。

### 3. 与字典（Key-Value）的区别

你提到的 `key-value` 结构在 Python 中被称为 **字典（dict）**。

- **字典（Dictionary）**：是一种数据结构，用于存储键值对，例如 `{"name": "Carl", "age": 18}`。
- **`map()` 函数**：是一个逻辑工具，用于“映射”转换。它虽然也叫“映射”，但指的是**数学上的函数映射**（把 A 集合的元素通过函数变成 B 集合的元素），而不是存储对应关系的容器。

------

**总结：**

这行代码的逻辑顺序是：

1. **转换**：用 `map(str, path)` 把路径里的数字全变字符串。
2. **拼接**：用 `'->'.join(...)` 把这些字符串用箭头连起来。

这就避开了手动写 `for` 循环拼接字符串的麻烦。

你想了解一下如何用 `for` 循环代替这行代码来实现同样的效果吗？



Q: def traversal(self, cur, path, result) -> void: 

对于无返回值的情况, 这里可以这样写吗



在 Python 的类型提示（Type Hints）中，对于没有返回值的函数，你应该使用 **`None`** 而不是 `void`。

### 为什么不能用 `void`？

1. **Python 语法规范**：`void` 是 C/C++、Java 等语言中的关键字。在 Python 中，如果一个函数没有显式执行 `return` 语句，或者只写了 `return` 但后面没跟值，它默认返回的是内置常量 **`None`**。
2. **标准写法**：Python 的 `typing` 模块和官方 PEP 484 规范规定，不返回值的函数应当标注为 `-> None`。

------

### 正确的写法示例

你可以按照以下方式修改你的函数定义：

Python

```
# 推荐写法：使用 None
def traversal(self, cur, path, result) -> None:
    # 你的逻辑代码...
    pass
```

### 补充建议

在你的代码截图逻辑中，如果你希望类型检查更加严谨，可以结合你之前问过的 `Optional` 进行更完整的标注：

Python

```
from typing import List, Optional

def traversal(self, cur: TreeNode, path: List[int], result: List[str]) -> None:
    # 这样写不仅标注了返回值，还清晰地标注了每个参数的类型
    path.append(cur.val)
    # ... 后续逻辑
```

**总结**：在 Python 中，请始终使用 **`-> None`** 来表示该函数不返回任何有效数据。

你要不要试试把这段带类型提示的完整代码在你的编辑器里运行一下，看看 IDE 是否能正确识别这些类型？