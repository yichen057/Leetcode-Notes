# 题654: 最大二叉树

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。
# 方法一: 切片法, 时间和空间复杂度都是O(n^2)
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]: # 1. 确定递归函数的参数和返回值, 传入的为已知正整数的数组, 即递归对象是数组区间
        # 2. 递归的终止条件: 区间长度为1, 保证数组至少有一个元素, 如果传进来的数组大小为1, 说明构造的是根节点
        if len(nums) == 1:
            return TreeNode(nums[0]) # 数组里唯一的元素
        # node = TreeNode(0) # 是表示这里有一个节点，只是它的值暂时是 0
        # 3. 单层递归逻辑: 在每一层递归中，有两个O(k)的操作（$k$ 为当前数组长度）：找最大值：for 循环遍历整个数组，耗时 $O(k)$。创建切片：nums[:idx]。Python 的切片会申请新内存并复制元素，耗时 $O(k)$。最坏情况（数组 [1,2,3,4,5]）：第 1 层处理 $n$ 个数，耗时 $n$。第 2 层处理 $n-1$ 个数，耗时 $n-1$。... 累加结果为 $\frac{n(n+1)}{2}$，即 $O(n^2)$

        # 中: 找到数组中最大的值和对应的下标
        maxValue = 0  # 题目说传入的是已知的正整数数组
        maxValueIndex = 0
        for i in range(len(nums)): # 找最大值：依然是 for i in range(left, right)，耗时 O(k)。
            if nums[i] > maxValue:
                maxValue = nums[i]
                maxValueIndex = i
        # node.val = maxValue # 对应的上面创建的node = TreeNode(0)
        node = TreeNode(maxValue)
        # 构造左子树和右子树, 保证左右区间至少有一个元素. 里面的 if判断必须写, 防止切出空数组. 因为递归终止条件并没有判断not root, return None
        # 左: 最大值所在的下标左区间, 构造左子树
        if maxValueIndex > 0: # 表示最大值的左边还有数, 如果没有数了就没必要去递归构造左子树, 因为左边是空的
            new_leftlist = nums[:maxValueIndex] # 左闭右开区间, 切片, 同时也新创建了数组
            node.left = self.constructMaximumBinaryTree(new_leftlist)
        # 右: 最大值所在的下标右区间, 构造右子树
        if maxValueIndex < len(nums) - 1: # 表示最大值的右边还有数, 如果最大值就在数组最右边, 那么右区间是空的
            new_rightlist = nums[maxValueIndex+1:]
            node.right = self.constructMaximumBinaryTree(new_rightlist)
        return node
    
# 方法二(优化, 更优): 使用下标, 时间复杂度O(n^2), 空间复杂度O(n)
class Solution:
    def constructMaximumBinaryTree(self, nums:List[int]) -> TreeNode:
        return self.traversal(nums, 0, len(nums))
    def traversal(self, nums: List[int], left:int, right:int) -> TreeNode:
        if left >= right:
            return None
        # 1. 初始化：假设第一个元素（下标为 left）就是最大的
        maxValueIndex = left
        # 2. 既然已经假设 left 是最大的了，那么比较的时候就不需要再和自己比. 所以循环从 left + 1 开始，去和后面的元素比
        for i in range(left+1, right):
            if nums[i] > nums[maxValueIndex]:
                maxValueIndex = i
        root = TreeNode(nums[maxValueIndex])
        # “切割”动作：仅仅是传了两个整数 left 和 right。这是O(1)操作，没有搬运数据的过程
        # 时间复杂度虽然在量级上（大 O 表示法）可能还是 $O(n^2)$，但系数小了很多，因为它省去了昂贵的内存拷贝时间
        # 空间复杂度为O(n)：全程只用那一个原始数组 nums，没有产生任何 new_nums。递归栈：依然是O(n)。结果：总空间消耗仅为O(n)。
        root.left = self.traversal(nums, left, maxValueIndex)
        root.right = self.traversal(nums, maxValueIndex+1, right)
        return root
```

Q: 654题有个疑问, 为什么单层递归里, 左右区别要写if判断, 每个if判断的含义是什么? 一般什么时候左右子树递归要写if,什么时候不用写? 另外递归的终止条件, 为啥不是碰到叶子节点就暂停, 而是判断数组的长度是否为1呢

这是一个非常深入的问题，触及了递归算法中**“边界处理”**的核心逻辑。我们以 [654. 最大二叉树](https://programmercarl.com/0654.最大二叉树.html) 为例，拆解这些代码设计的深意。

------

### 1. 为什么单层递归要写 `if` 判断？

在 654 题（最大二叉树）中，你通常会看到类似这样的代码：

Python

```python
# 找到最大值索引 maxValueIndex 后
if maxValueIndex > 0: # 处理左区间
    root.left = self.constructMaximumBinaryTree(nums[:maxValueIndex])

if maxValueIndex < len(nums) - 1: # 处理右区间
    root.right = self.constructMaximumBinaryTree(nums[maxValueIndex + 1:])
```

这两个 `if` 的含义是：**确保“分割后的区间”里至少还有一个元素。**

- **`if maxValueIndex > 0`**：表示最大值的左边还有数。如果没有数了（比如最大值就在数组最左边），我们就没必要去递归构造左子树，因为左边是空的。
- **`if maxValueIndex < len(nums) - 1`**：表示最大值的右边还有数。如果最大值就在数组最右边，右区间就是空的。

**如果不写会怎样？**

如果你不写 `if`，直接把一个空的列表 `[]` 传进递归函数，程序就会报错（因为你在下一层试图找空列表的最大值 `max([])`）。

------

### 2. 什么时候写 `if`，什么时候不用写？

这是一个很棒的通用逻辑总结：

#### 情况 A：需要写 `if`（如 654、106 题）

当你的递归逻辑是 **“先切割，后进入”** 时，你必须在**进入下一层之前**确保区间有效。

- **特征**：你在当前层通过下标手动切分数组。
- **目的**：防止把“空集”传给下一层，导致下一层在处理 `nums[0]` 或 `max(nums)` 时崩掉。

#### 情况 B：不需要写 `if`（如 112 路径总和、226 翻转二叉树）

当你的递归逻辑是 **“先进入，后判断”** 时，通常不需要写 `if`。

- **特征**：你直接写 `traversal(root.left)`。
- **做法**：在递归函数的**最开头**统一写一个终止条件：`if not root: return None`。
- **逻辑**：即便左孩子是空的，我们也允许它进入下一层，让下一层开头的“判空”逻辑来温柔地把它弹回来。

------

### 3. 终止条件：为啥是长度为 1 而不是叶子节点？

这也是 654 题（构造类题目）和 113 题（遍历类题目）最大的区别：

#### 遍历类（如 113 路径总和）：

- **对象**：是一棵**已经长好**的树。
- **逻辑**：你已经站在节点上了，所以判断“我是不是叶子”。

#### 构造类（如 654 最大二叉树）：

- **对象**：是一个**待切割的数组**，树还没长出来呢！
- **逻辑**：
  - 如果数组长度为 1，说明这个区间里只有一个数了。
  - 那么这个数**注定**会成为一个叶子节点（因为它左边没数，右边也没数）。
  - 所以，直接 `return TreeNode(nums[0])` 效率最高。

> **更底层的真相**：其实你也可以把终止条件写成 `if not nums: return None`。但为了代码更精简，我们通常在当前层通过 `if` 保证了传进去的数组不为空，那么数组长度为 1 就成了最底层的“保底”条件。

------

### 4. 总结对比

| **维度**     | **构造类 (654 / 105 / 106)** | **遍历类 (113 / 129)**               |
| ------------ | ---------------------------- | ------------------------------------ |
| **递归对象** | 数组区间 (nums)              | 树节点 (TreeNode)                    |
| **终止条件** | 区间长度为 1 (叶子预兆)      | 节点为 Leaf (路径终点)               |
| **if 判断**  | 必须写，防止切出空数组       | 可写可不写，取决于是否允许进入空节点 |

**如果你把 654 题看作是“从一堆零件（数组）里组装车”，而把 113 题看作是“在一辆组装好的车（树）里开车”，你就明白为什么构造题要时刻盯着数组长度了。**

**要不要试着把 654 题这种“先判断再递归”的写法，改成“直接递归但在开头判空”的写法对比一下？这样能让你对递归的控制感更强。**



Q:  node = TreeNode(0)是什么意思?

简单来说，这一行代码的意思是：**在内存里徒手“造”出了一个二叉树的节点。**

我们可以从**语法**、**内存**和**形象类比**三个角度来拆解：

### 1. 语法拆解

- **`TreeNode`**: 这是一个**类（Class）**，相当于一张“图纸”，规定了一个二叉树节点应该长什么样（通常包含 `val`, `left`, `right` 三个属性）。
- **`(0)`**: 这是给构造函数的**传参**。它告诉程序：新造出来的这个节点，它的数值（`val`）设为 `0`。
- **`node = ...`**: 这是一个**赋值**操作。把新造出来的这个节点对象，交给变量名 `node` 来管理。

------

### 2. 内存里的真实样子

当你运行这行代码后，计算机内存里就多了一个小空间，里面存了三样东西：

1. **`val`**: 0
2. **`left`**: `None`（默认左手是空的）
3. **`right`**: `None`（默认右手是空的）

------

### 3. 形象类比：乐高积木

你可以把 `TreeNode` 想象成一种**特殊的乐高积木**：这种积木中间可以写个数字，左边有一个插孔，右边也有一个插孔。

- 执行 `node = TreeNode(0)`：相当于你从零件盒里拿出一个新的积木，在中间写上数字 `0`，并把它放在桌子上，起名叫 `node`。
- 如果你接着写 `node.left = TreeNode(1)`：相当于你又拿出一块数字是 `1` 的积木，插在了第一块积木的左插孔里。

------

### 4. 为什么我们在算法题里经常看到它？

在构造类题目（比如你刚才看的 654、105、106 题）中，这一步是**“从无到有”**的关键：

- 数组里只是冷冰冰的**数字**。
- 我们要把数字转成**节点对象**，才能用 `.left` 和 `.right` 把它们串成一棵真正的树。

### 总结

`node = TreeNode(0)` 就是**初始化了一个数值为 0 的独立节点**。它目前还是个“孤家寡人”，左右都没有连上其他节点。

**在你看到的 654 题代码里，是不是先通过这句造出了 `root`，然后才去递归构造它的 `root.left` 和 `root.right` 的？**



Q: 使用下标方法里, for i in range(left + 1, right):这个for循环没明白, 为啥起点是left+1? 为啥不是left呢

这是一个非常细微且关键的边界问题。

在 **654. 最大二叉树** 的“下标优化法”中，`for` 循环的目的是为了在给定的区间 `[left, right)` 里找到最大值的索引。

之所以起点写成 `left + 1`，是因为我们在初始化 `maxValueIndex` 时，已经**默认把第一个元素（也就是 `left` 位置的元素）当成初始最大值了**。

### 1. 逻辑拆解

请看这段典型的下标法初始化代码：

Python

```
# 1. 初始化：假设第一个元素（下标为 left）就是最大的
maxValueIndex = left 

# 2. 既然已经假设 left 是最大的了，那么比较的时候就不需要再和自己比
# 所以循环从 left + 1 开始，去和后面的元素比
for i in range(left + 1, right):
    if nums[i] > nums[maxValueIndex]:
        maxValueIndex = i
```

- **如果从 `left` 开始**：循环会执行一次 `if nums[left] > nums[maxValueIndex]`（也就是 `nums[left] > nums[left]`）。虽然结果是 `False`，代码也能跑通，但**多做了一次无意义的自比**。
- **如果从 `left + 1` 开始**：代码更简洁高效，直接拿“当前擂主”去挑战后面的“竞争者”。

------

### 2. 为什么 `range` 的终点是 `right`？

这取决于你对边界的定义。在 Python 习惯和 `range` 语法中，通常使用**左闭右开**区间，即 `[left, right)`：

- `left`：区间内第一个元素的索引。
- `right`：区间内最后一个元素的**下一个**索引。

所以 `range(left + 1, right)` 刚好覆盖了从第二个元素到最后一个元素的所有位置。

------

### 3. 形象比喻：选班长

想象你要从一排学生（下标从 `left` 到 `right-1`）里选一个最高的当班长：

1. 你先指着**第一个学生**（下标 `left`）说：“你先站在台上当擂主。”（`maxValueIndex = left`）
2. 然后你转身对**剩下的学生**（从 `left + 1` 到最后）说：“你们一个个上来跟他比身高，谁更高谁就换他站上来。”

**既然第一个学生已经在台上了，你当然是从第二个学生开始点名。**

------

### 4. 易错点提示

如果你在初始化时没有给 `maxValueIndex` 赋值，而是这样写：

Python

```
# 错误示范
maxValueIndex = -1 
for i in range(left, right): # 这时必须从 left 开始
    if maxValueIndex == -1 or nums[i] > nums[maxValueIndex]:
        maxValueIndex = i
```

这种写法虽然也行，但逻辑上比较啰嗦。所以**“默认第一个是最大，从第二个开始比”**是处理这类问题的最简范式。

### 总结

- 起点 `left + 1`：是因为 `left` 已经被预设为初始最大值了。
- 终点 `right`：是因为 `range` 不包含右边界，刚好扫描到最后一个元素。

**这个逻辑理顺后，你再看右子树的递归调用 `helper(maxValueIndex + 1, right)`，是不是也能一眼看出来它是跳过了当前的老大，去处理剩下的右半部分了？**



Q: 对比本题的这几个方法的时间和空间复杂度, 且讲解如何计算的

在 **654. 最大二叉树** 中，对比“原始切片法”和“下标优化法”的复杂度是非常有意义的，因为这能帮你建立起对“数据拷贝”和“逻辑划分”底层开销的深刻理解。

------

### 1. 复杂度对比表

| **维度**       | **原始切片法 (nums[:idx])** | **下标优化法 (left, right)**                   | **差距原因**                                     |
| -------------- | --------------------------- | ---------------------------------------------- | ------------------------------------------------ |
| **时间复杂度** | **$O(n^2)$**                | **$O(n^2)$** (最坏) / **$O(n \log n)$** (平均) | 两者在“找最大值”上耗时一致，但切片多了拷贝开销。 |
| **空间复杂度** | **$O(n^2)$**                | **$O(n)$**                                     | 是否产生了数组的物理副本。                       |

> **注意：** 即使使用了下标优化，找最大值的 `for` 循环在最坏情况下（数组单调递增或递减）依然是 $O(n^2)$。要达到真正的 $O(n)$，需要使用更高级的数据结构（单调栈），这通常是该题的进阶考点。

------

### 2. 原始切片法：为什么是 $O(n^2)$？

#### **时间复杂度计算：**

在每一层递归中，有两个 $O(k)$ 的操作（$k$ 为当前数组长度）：

1. **找最大值**：`for` 循环遍历整个数组，耗时 $O(k)$。
2. **创建切片**：`nums[:idx]`。Python 的切片会**申请新内存并复制元素**，耗时 $O(k)$。

- **最坏情况（数组 `[1,2,3,4,5]`）**：
  - 第 1 层处理 $n$ 个数，耗时 $n$。
  - 第 2 层处理 $n-1$ 个数，耗时 $n-1$。
  - ... 累加结果为 $\frac{n(n+1)}{2}$，即 **$O(n^2)$**。

#### **空间复杂度计算：**

这是切片法最大的短板。

- **递归栈**：最深 $O(n)$ 层。
- **内存副本**：每一层都产生新数组。第 1 层存了 $n$ 个数，第 2 层存了 $n-1$ 个数... 这些数组在递归返回前都堆积在内存里。
- **结果**：$n + (n-1) + \dots + 1 = \mathbf{O(n^2)}$。

------

### 3. 下标优化法：提升在哪里？

#### **时间复杂度计算：**

1. **找最大值**：依然是 `for i in range(left, right)`，耗时 $O(k)$。
2. **“切割”动作**：仅仅是传了两个整数 `left` 和 `right`。**这是 $O(1)$ 操作**，没有搬运数据的过程。

- **结论**：时间复杂度虽然在量级上（大 O 表示法）可能还是 $O(n^2)$，但**系数小了很多**，因为它省去了昂贵的内存拷贝时间。

#### **空间复杂度计算：**

1. **无副本**：全程只用那一个原始数组 `nums`，没有产生任何 `new_nums`。
2. **递归栈**：依然是 $O(n)$。
3. **结果**：总空间消耗仅为 **$O(n)$**。

------

### 4. 深度总结：如何计算复杂度？

在分析递归算法时，你可以套用这个简单的公式：

> **总复杂度 = 递归树的节点数 $\times$ 每一个节点内做的“体力活”**

1. **算节点内工作量**：
   - 看有没有循环（`for` 是 $O(k)$）。
   - 看有没有内置的高级操作（切片 `[:]`、`index()`、`max()` 都是 $O(k)$）。
   - 如果只有简单的加减法和赋值，就是 $O(1)$。
2. **算树的形状**：
   - **最好情况**（数组像平衡树）：树高 $\log n$，每层总工作量 $n$，总计 $O(n \log n)$。
   - **最坏情况**（数组单调）：树高 $n$，工作量等差数列求和，总计 $O(n^2)$。

### 核心启示

在二叉树构造类题目中，**“下标法”\**是面试官最想看到的写法。它展示了你对\**内存敏感度**的把控——即“能引用就不拷贝”。

**你现在已经能熟练计算 $O(n^2)$ 和 $O(n)$ 的区别了。要不要尝试挑战一下这道题真正的 $O(n)$ 解法（单调栈）？那个思路会让你对“找左右第一个比我大的数”有全新的认识。**



Q:  空间复杂度有点不理解, 如果每层产生一个数组, 那一个数组的空间复杂度不就1吗?

这是一个非常经典的学习误区，你能问出这个问题说明你在思考**数据在内存中到底是怎么占地方的**。

我们来拆解一下为什么“产生一个数组”的空间复杂度**不是 $O(1)$**，而是由数组的**长度**决定的。

### 1. 数组长度决定空间大小

在计算机中，空间复杂度衡量的是**额外占用的存储单元个数**。

- 如果你定义一个变量 `a = 1`，它只占 1 个位置，空间复杂度是 $O(1)$。
- 但如果你创建一个数组 `nums = [1, 2, 3, 4, 5]`，它在内存里实打实地占用了 **5 个位置**。
- 所以，一个长度为 $k$ 的数组，它占用的空间是 **$O(k)$**。

### 2. 递归中的“堆叠效应”（切片法）

在 654 题或 106 题中，如果你用切片法，每一层递归都会产生**新数组**。我们看最坏情况（数组长度为 $n$）：

- **第一层**：你接收 `nums`（长度 $n$）。
- **第二层**：你切出了 `left_nums`，它可能包含 $n-1$ 个元素。此时，**原数组和新数组同时存在于内存中**。
- **第三层**：你又切出了一个长度为 $n-2$ 的数组。

**重点在这里**：递归在向下钻取时，上一层的函数并没有结束，所以上一层的数组也不会被销毁。

这就好比你为了分发任务，复印了 $n$ 页纸给第一人，第一人复印了 $n-1$ 页给第二人，第二人复印了 $n-2$ 页给第三人……

当你下到最深一层时，手里攒着的总纸张数是：

$$n + (n-1) + (n-2) + \dots + 1 = \frac{n(n+1)}{2}$$

这就是为什么切片法的空间复杂度是 **$O(n^2)$**。

------

### 3. 下标法为什么是 $O(n)$？

下标法（只传 `left` 和 `right` 指针）高明在哪里？

- **它不复印纸张**。
- 全程只有那**一张原稿**（原始数组，长度 $n$）。
- 每一层递归，你只是在脑子里记住了两个数字（`left` 和 `right`），这两个数字确实只占 $O(1)$。
- 即使递归了 $n$ 层，你也就记了 $n \times 2$ 个数字。

加上递归调用产生的“栈空间”（系统为了记住“我从哪一层跳过来的”），总空间也就是 $n$（原数组） + $n$（递归栈） = **$O(n)$**。

------

### 4. 形象对比：分蛋糕

假设你要把一个大蛋糕分给 10 个人看：

- **切片法（$O(n^2)$）**：你每分给一个人，都要去后厨**重新做一个**稍微小一点的蛋糕送过去。当你送到第 10 个人时，店里已经摆了 10 个不同尺寸的蛋糕，非常占空间。
- **下标法（$O(n)$）**：你手里始终只有**那一个蛋糕**。你分给每个人时，只是用手指着蛋糕说：“你只能看这一块，剩下的不准看。” 哪怕有 100 个人看，店里也只有一个蛋糕。

### 总结

- **数组的“1”**：是指 1 个**对象**。
- **复杂度的“1”**：是指 **1 个存储单位**（即常数级）。
- **真相**：数组虽然是 1 个对象，但它内部装了 $k$ 个数，所以空间是 **$O(k)$**。

**现在你明白为什么“切片法”在处理大数据量时，不仅跑得慢（时间 $O(n^2)$），还会因为吃内存（空间 $O(n^2)$）导致程序崩溃了吗？**



# 题617. 合并二叉树

```python
# @lc code=start
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 合并二叉树, 本题考察一起操作两个二叉树的能力
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]: # 1. 参数是两个数的根节点, 返回值是合并后的根节点
        # 2. 递归终止条件
        if not root1:
            return root2
        if not root2:
            return root1 
        # 上面的递归终止条件保证了代码执行到这里root1, root2都非空
        # 3. 单层递归, 此处用前序遍历, 中序和后序也可做
        # 方法一: 前序+修改root1: 本方法直接改tree1的结构, 无需重新定义tree, 合并后的二叉树直接用tree1的结构
        # root1.val += root2.val # 中
        # root1.left = self.mergeTrees(root1.left, root2.left) # 左
        # root1.right = self.mergeTrees(root1.right, root2.right) # 右

        # return root1 #  注意: 本题我们重复使用了题目给出的节点而不是创建新节点. 节省时间, 空间. 
    
        # 方法二: 前序+新建root
        root = TreeNode() # 创建新节点. 当你写 TreeNode() 时：你没有传参数，Python 自动使用了默认值 val=0。
        # 永远不要提前创建一个“空壳”节点，而是等拿到了正确的数值后，再通过 TreeNode(correct_val) 把它生出来。
        root.val += root1.val+root2.val # 中
        root.left = self.mergeTrees(root1.left, root2.left) # 左
        root.right = self.mergeTrees(root1.right, root2.right) # 右

        return root  #注意: 本题我们创建了新节点. 


# @lc code=end
```



Q:  root = TreeNode() # 创建新节点, 这里为啥不能初始化为root=TreeNode(0)呢

这是一个非常棒的细节观察。其实，在 Python 中 `root = TreeNode()` 和 `root = TreeNode(0)` 在**语法上几乎是等价的**，但在**逻辑意图**和**默认值处理**上，它们有细微的差别。

我们可以从以下三个维度来分析：

### 1. 语法层面的真相

正如你之前看到的 `TreeNode` 定义：

Python

```
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        ...
```

- 当你写 `TreeNode()` 时：你没有传参数，Python 自动使用了默认值 `val=0`。
- 当你写 `TreeNode(0)` 时：你显式地告诉 Python “我要这个值是 0”。

**结论：** 最终在内存里产生的节点，其 `val` 都是 `0`。所以，**并不是不能写 `TreeNode(0)`，它们其实是一回事。**

------

### 2. 为什么有时候“不推荐”写死一个值？

虽然两者结果一样，但在写算法题时，大家习惯上的选择体现了不同的逻辑：

#### **情况 A：作为“虚拟头结点”（Dummy Node）**

在某些题目（如合并链表或复杂的树转换）中，我们会先造一个“假根”。

- 写 `TreeNode(0)` 或 `TreeNode(-1)`：通常是为了提醒自己，“这个节点里的值是没意义的，只是个占位符”。

#### **情况 B：在构造树的过程中（如 654 题）**

如果你在构造最大二叉树，你是先找到了 `maxValue`，然后才去造节点。

- **写法 1（推荐）**：`root = TreeNode(maxValue)`。一步到位，直接给对的值。
- **写法 2（不推荐）**：`root = TreeNode(0)` 然后 `root.val = maxValue`。这就像是先生产了一个次品（值是 0），然后再去修理它（改成 maxValue）。虽然不犯法，但显得多此一举。

------

### 3. 一个潜藏的坑：如果 0 也是有效值怎么办？

这是为什么有些老手不喜欢写 `TreeNode(0)` 的原因。

假设一棵树的所有节点值都是正数，你初始化一个 `0`，别人一看就知道这是个初始化的临时值。

但如果题目给的节点值**范围包括 0**（比如数组里就有 0）：

- 如果你初始化了 `root = TreeNode(0)` 但后面因为逻辑漏洞忘记给它重新赋值了。
- 你的程序运行起来不会报错，但结果里会莫名其妙多出一个值为 0 的节点，你很难 debug 发现是哪里出的错。

------

### 4. 总结：你应该怎么写？

在二叉树构造类题目（654, 105, 106）中，最好的习惯是：

> **永远不要提前创建一个“空壳”节点，而是等拿到了正确的数值后，再通过 `TreeNode(correct_val)` 把它生出来。**

Python

```
# 推荐写法
val = nums[max_idx]
root = TreeNode(val) # 出生即正确

# 不太好的写法
root = TreeNode() # 此时 root.val 是 0，如果 max_idx 指向的值其实是 10，这行就产生了歧义
root.val = nums[max_idx]
```

**所以，回答你的疑问：你可以写 `TreeNode(0)`，它不会报错。但为了代码的“语义清晰”（即：让代码一眼看上去就知道在干什么），我们通常直接把目标值传进去。**

**通过这几题的练习，你已经对 `TreeNode` 的生命周期非常熟悉了。你现在是准备把 654 题的“下标优化版”完整跑通一遍，还是想看看这道题如何用更高级的“单调栈”来达到 $O(n)$ 时间复杂度？**