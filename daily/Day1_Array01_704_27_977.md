# LeetCode Day 1笔记：数组01-704 / 27 / 977
_最后更新：2025-09-18_

---

## 704. Binary Search（二分查找）

二分使用的前提: 有序数组. 因此看到有序数组的第一时间反问自己是否可以使用二分法

二分最大的优势是: 其时间复杂度是O(log n)

### 核心流程

- 在**有序数组**中查找目标 `target`：
  1. `left = 0, right = n - 1`（闭区间）
  2. 循环条件 `while left <= right:`
  3. `mid = left + (right - left) // 2`（防溢出写法）
  4. 比较 `nums[mid]` 与 `target` 并收缩区间

### 易错点:

1. while left <= right, 这里该不该加等号: 区分左闭右开和左闭右闭. 

   - 当l=0, r=n-1时因为r这个值在数组中可以取到, 所以while(left < =right)左闭右闭是正确写法. 一般是找具体元素用这个

   - 当l=0, r=n时因为r这个值在数组中无法取到, 所以while(l<r), 左闭右开区间是正确写法, 一般找边界/插入点用这个

- **查找具体元素**：用闭区间 `[left, right]` → `while left <= right`
- **查找边界/插入点**：用左闭右开 `[left, right)` → `while left < right`，且初始化 `right = n`、收缩时 `right = mid`

2. if nums[mid] >target: right = mid-1 包含右边的值or right = mid不包含右边的值. right和left的取值要注意. 
3. 求middle的方式和何时计算middle要注意, 涉及二分溢出问题

​	1) 求middle的方式

- ✅ `mid = left + (right - left) // 2`：推荐，能避免整型溢出（Python 不溢出，但通用最安全）  
- ⚠️ `mid = (left + right) // 2`：语义等价，部分语言可能溢出  
- ❌ `mid = right // 2`：忽略了 `left`，在 `left != 0` 时会错  
- ❌ `mid = right / 2`：Python 得到浮点数，不能做下标
  2) 何时计算middle: **没有在循环内更新 `mid`**，导致死循环或错误结果。

### 代码（查找元素是否存在，返回索引）
```python
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid
        return -1
      
      
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        
        while left <= right:
            middle = left + (right - left) // 2
            if nums[middle] > target:
                right = middle - 1
            elif nums[middle] < target:
                left = middle + 1
            elif nums[middle] == target:
                return middle
        return -1
```

---

## 27. Remove Element（移除元素）

题意：**原地**移除数组中等于 `val` 的元素，返回新长度 `k`，并保证 `nums[:k]` 是移除后的内容（顺序可不保）。

### 常见错误（源自提问）
- `for i in nums:` 遍历到的是**元素值**而非下标，后续用 `nums[i]` 会错
- 只统计个数、不覆盖数组 → 没有“原地修改”
- 在 `for` 循环里手动 `i += 1` 不生效（`for` 自增由解释器处理）

### 写法一：暴力删除（O(n²)，直观）
```python
class Solution:
    def removeElement(self, nums: list[int], val: int) -> int:
        i, n = 0, len(nums)
        while i < n:
            if nums[i] == val:
                nums.pop(i)  # 右侧整体左移
                n -= 1
            else:
                i += 1
        return n
```

当 `nums[i] == val` 时，它会 `pop(i)` 删除当前位置元素，**右边元素左移**，所以不用 `i += 1`。

循环继续检查当前位置，直到不是 `val` 才前进。
✅ 这样可以删除**所有等于 `val` 的元素**。
但注意时间复杂度是 **O(n²)**，因为 `pop(i)` 每次都要移动右边的元素。

### 写法二：双指针覆盖（O(n)，保相对顺序，推荐）

```python
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
      # 快指针用来获取新数组中的元素, 慢指针用来获取新数组中需要更新的位置, 二者都在同一个数组中操作
        slow = 0
        # python的for 里你不需要写 fast = 0 和 fast += 1，否则就重复了。
        for fast in range(len(nums)):            # for 会自动处理 fast 的初始化与递增
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
        return slow                               # 新长度；有效区间为 nums[:slow]
```

> 补充：使用 `while` 时需要手动 `fast = 0` 和 `fast += 1`，否则会死循环。
>
> `fast` 指针遍历数组，每当发现一个不是 `val` 的元素，就覆盖到 `slow` 指针的位置。
>
> `slow` 只在遇到非 `val` 时才前进。
> ✅ 所以无论 `val` 出现多少次，它们都会被跳过，最后 `nums[:slow]` 就是去掉 `val` 的新数组。
> 复杂度 **O(n)**。

### 写法三：与末尾交换（O(n)，不保序，写操作更少）
```python
class Solution:
    def removeElement(self, nums: list[int], val: int) -> int:
        i, n = 0, len(nums)
        while i < n:
            if nums[i] == val:
                nums[i] = nums[n - 1]  # 用末尾覆盖
                n -= 1                 # 缩短有效区间
            else:
                i += 1
        return n
```

每次遇到 `val`，用末尾元素覆盖，再把有效长度 `n` 缩短 1。

不移动指针 `i`，因为换过来的新值也要检查。
✅ 所以能正确移除所有等于 `val` 的元素。
缺点是**不保序**（顺序会被打乱）。

### ✅ 结论

无论有 1 个还是多个等于 `val` 的元素，**这三种算法都能正确移除**，区别在于性能和是否保序：

| 方法       | 复杂度 | 保序 | 适用场景       |
| ---------- | ------ | ---- | -------------- |
| 暴力 pop   | O(n²)  | ✅    | 小数组，直观   |
| 双指针覆盖 | O(n)   | ✅    | 推荐，一般情况 |
| 末尾交换   | O(n)   | ❌    | 不需要顺序时   |

------

## 977. Squares of a Sorted Array（有序数组的平方）

题意：给定非递减序列 `nums`，返回各元素平方后并**按非递减**排序的数组。

### 思路（双指针从两端向内，倒序填充）
- 因为负数平方后可能变大，所以比较两端绝对值，较大的平方放到结果数组的**末尾**。
- 指针：`l = 0`、`r = n - 1`、写指针 `i = n - 1`。  

### 常见错误

1. 如何定义空列表

   ## 1. `res = [0] * n`

   - 初始化成全 0。
   - 常见用途：**结果数组、占位数组**。
     - 比如 LeetCode 977 「有序数组的平方」里，我们最终要得到一组平方值，所以一开始用 0 占位，后面逐步写入。
   - 意味着「这些位置迟早会被覆盖」。

   ------

   ## 2. `res = [float('inf')] * n`

   - 初始化成全无穷大 (`inf`)。
   - 常见用途：**动态规划 / 最短路径 / 最小值问题**。
     - 一开始不知道答案，先放一个极大值，后面不断 `min()` 更新。
   - 语义上是「还没计算/不可达/未知」。

2. 左右边界对比, 找max. 对于有序数组的平方值, 最大值从两边找, 先取最大, 再取次大

3. l, r, i不能越界

- 如果把 `r` 和 `i` 赋成 `len(nums)`，会造成越界（下标最大是 `len(nums) - 1`）。

### 正确代码
```python
from typing import List

class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # 左指针l, 右指针r和指向数组终止位置的i
        l, r, i = 0, n - 1, n - 1
        # 提前定义列表存放结果
        res = [0] * n
         # 区别: 
        # 1) res = [0] * len(nums) 结果数组、占位, 初始化成全 0。 → [0] * n
        # 2) res = [float('inf')] * len(nums) 未知值，一开始不知道答案，先放一个极大值初始化成全无穷大 (inf)，后面不断 min() 更新。需要用 min 比较 → [float('inf')] * n
        while l <= r:
            if nums[l] ** 2 < nums[r] ** 2:
                res[i] = nums[r] ** 2
                r -= 1 # 右指针向左移动
            else:
                res[i] = nums[l] * nums[l]
                l += 1 # 左指针往右移动
            i -= 1 # 存放结果的指针需要往前平移一位
        return res
```

---

## 附：易混点小抄
- `float('inf')`：正无穷，用于初始化最小值比较；`[float('inf')] * n` 安全（不可变类型）。
- Python 幂运算：`x ** 2`（平方），`x ** 3`（立方）。
- `for fast in range(n)`：无需手写 `fast = 0` / `fast += 1`；若用 `while`，必须手动维护索引。

---

